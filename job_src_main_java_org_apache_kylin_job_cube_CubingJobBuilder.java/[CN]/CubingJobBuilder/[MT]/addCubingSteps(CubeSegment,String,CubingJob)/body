{
  final int groupRowkeyColumnsCount=seg.getCubeDesc().getRowkey().getNCuboidBuildLevels();
  final int totalRowkeyColumnsCount=seg.getCubeDesc().getRowkey().getRowKeyColumns().length;
  final String jobId=result.getId();
  final CubeJoinedFlatTableDesc intermediateTableDesc=new CubeJoinedFlatTableDesc(seg.getCubeDesc(),seg);
  final String intermediateHiveTableName=getIntermediateHiveTableName(intermediateTableDesc,jobId);
  final String intermediateHiveTableLocation=getIntermediateHiveTableLocation(intermediateTableDesc,jobId);
  final String factDistinctColumnsPath=getFactDistinctColumnsPath(seg,jobId);
  final String[] cuboidOutputTempPath=getCuboidOutputPaths(cuboidRootPath,totalRowkeyColumnsCount,groupRowkeyColumnsCount);
  final AbstractExecutable intermediateHiveTableStep=createIntermediateHiveTableStep(intermediateTableDesc,jobId);
  result.addTask(intermediateHiveTableStep);
  result.addTask(createFactDistinctColumnsStep(seg,intermediateHiveTableName,jobId));
  result.addTask(createBuildDictionaryStep(seg,factDistinctColumnsPath));
  MapReduceExecutable baseCuboidStep=null;
  if (!inMemoryCubing()) {
    baseCuboidStep=createBaseCuboidStep(seg,intermediateHiveTableLocation,cuboidOutputTempPath);
    result.addTask(baseCuboidStep);
    for (int i=1; i <= groupRowkeyColumnsCount; i++) {
      int dimNum=totalRowkeyColumnsCount - i;
      result.addTask(createNDimensionCuboidStep(seg,cuboidOutputTempPath,dimNum,totalRowkeyColumnsCount));
    }
  }
 else {
    result.addTask(createCreateHTableStep(seg));
    baseCuboidStep=createInMemCubingStep(seg,intermediateHiveTableLocation,intermediateHiveTableName,cuboidOutputTempPath,result.getId());
    result.addTask(baseCuboidStep);
    result.addTask(createBulkLoadStep(seg,result.getId()));
  }
  return new Pair<AbstractExecutable,AbstractExecutable>(intermediateHiveTableStep,baseCuboidStep);
}

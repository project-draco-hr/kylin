{
  final IIDesc desc=iiManager.getII(iiName).getDescriptor();
  final String tableName=createIntermediateTable(desc,kylinConfig);
  logger.info("intermediate table name:" + tableName);
  HiveTableReader reader=new HiveTableReader("default",tableName);
  final List<TblColRef> tblColRefs=desc.listAllColumns();
  for (  TblColRef tblColRef : tblColRefs) {
    if (desc.isMetricsCol(tblColRef)) {
      logger.info("matrix:" + tblColRef.getName());
    }
 else {
      logger.info("measure:" + tblColRef.getName());
    }
  }
  LinkedBlockingDeque<StreamMessage> queue=new LinkedBlockingDeque<StreamMessage>();
  final IISegment segment=createSegment(iiName);
  String[] args=new String[]{"-iiname",iiName,"-htablename",segment.getStorageLocationIdentifier()};
  ToolRunner.run(new IICreateHTableJob(),args);
  ExecutorService executorService=Executors.newSingleThreadExecutor();
  final StreamBuilder streamBuilder=StreamBuilder.newLimitedSizeStreamBuilder(iiName,queue,new IIStreamConsumer(iiName,segment.getStorageLocationIdentifier(),segment.getIIDesc(),0),0,segment.getIIDesc().getSliceSize());
  List<String[]> sorted=getSortedRows(reader,desc.getTimestampColumn());
  int count=sorted.size();
  for (  String[] row : sorted) {
    logger.info("another row: " + StringUtils.join(row,","));
    queue.put(parse(row));
  }
  reader.close();
  logger.info("total record count:" + count + " htable:"+ segment.getStorageLocationIdentifier());
  queue.put(StreamMessage.EOF);
  final Future<?> future=executorService.submit(streamBuilder);
  try {
    future.get();
  }
 catch (  Exception e) {
    logger.error("stream build failed",e);
    fail("stream build failed");
  }
  logger.info("stream build finished, htable name:" + segment.getStorageLocationIdentifier());
}

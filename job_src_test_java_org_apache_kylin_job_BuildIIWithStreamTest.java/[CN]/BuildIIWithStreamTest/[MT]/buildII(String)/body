{
  final IIDesc desc=iiManager.getII(iiName).getDescriptor();
  final String tableName=createIntermediateTable(desc,kylinConfig);
  logger.info("intermediate table name:" + tableName);
  final Configuration conf=new Configuration();
  HCatInputFormat.setInput(conf,"default",tableName);
  final HCatSchema tableSchema=HCatInputFormat.getTableSchema(conf);
  logger.info(StringUtils.join(tableSchema.getFieldNames(),"\n"));
  HiveTableReader reader=new HiveTableReader("default",tableName);
  final List<TblColRef> tblColRefs=desc.listAllColumns();
  for (  TblColRef tblColRef : tblColRefs) {
    if (desc.isMetricsCol(tblColRef)) {
      logger.info("matrix:" + tblColRef.getName());
    }
 else {
      logger.info("measure:" + tblColRef.getName());
    }
  }
  LinkedBlockingDeque<Stream> queue=new LinkedBlockingDeque<Stream>();
  final IISegment segment=createSegment(iiName);
  String[] args=new String[]{"-iiname",iiName,"-htablename",segment.getStorageLocationIdentifier()};
  ToolRunner.run(new IICreateHTableJob(),args);
  ExecutorService executorService=Executors.newSingleThreadExecutor();
  final IIStreamBuilder streamBuilder=new IIStreamBuilder(queue,segment.getStorageLocationIdentifier(),segment.getIIInstance(),0);
  int count=0;
  while (reader.next()) {
    queue.put(parse(reader.getRow()));
    count++;
  }
  reader.close();
  logger.info("total record count:" + count + " htable:"+ segment.getStorageLocationIdentifier());
  queue.put(Stream.EOF);
  final Future<?> future=executorService.submit(streamBuilder);
  try {
    future.get();
  }
 catch (  Exception e) {
    logger.error("stream build failed",e);
    fail("stream build failed");
  }
  logger.info("stream build finished, htable name:" + segment.getStorageLocationIdentifier());
}

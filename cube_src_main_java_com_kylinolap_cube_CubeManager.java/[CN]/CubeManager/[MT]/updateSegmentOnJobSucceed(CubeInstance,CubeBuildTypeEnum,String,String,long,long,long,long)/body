{
  List<CubeSegment> segmentsInNewStatus=cubeInstance.getSegments(SegmentStatusEnum.NEW);
  CubeSegment cubeSegment=cubeInstance.getSegmentById(jobUuid);
  Preconditions.checkArgument(segmentsInNewStatus.size() == 1,"there are " + segmentsInNewStatus.size() + " new segments");
switch (buildType) {
case BUILD:
    if (cubeInstance.needMergeImmediatelyAfterBuild(cubeSegment)) {
      cubeInstance.getSegments().removeAll(cubeInstance.getMergingSegments());
    }
 else {
      cubeInstance.getSegments().removeAll(cubeInstance.getRebuildingSegments());
    }
  break;
case MERGE:
cubeInstance.getSegments().removeAll(cubeInstance.getMergingSegments());
break;
case REFRESH:
break;
default :
throw new RuntimeException("invalid build type:" + buildType);
}
cubeSegment.setLastBuildJobID(jobUuid);
cubeSegment.setLastBuildTime(lastBuildTime);
cubeSegment.setSizeKB(sizeKB);
cubeSegment.setSourceRecords(sourceRecordCount);
cubeSegment.setSourceRecordsSize(sourceRecordsSize);
cubeSegment.setStatus(SegmentStatusEnum.READY);
cubeInstance.setStatus(RealizationStatusEnum.READY);
this.updateCube(cubeInstance);
}

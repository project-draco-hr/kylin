{
  if (cubeInstance.getBuildingSegments().size() > 0) {
    throw new RuntimeException("There is already an allocating segment!");
  }
  List<CubeSegment> segments=new ArrayList<CubeSegment>();
  boolean needMergeImmediately=cubeInstance.needMergeImmediately(startDate,endDate);
  if (null != cubeInstance.getDescriptor().getCubePartitionDesc().getPartitionDateColumn()) {
    if (needMergeImmediately) {
      segments.add(buildSegment(cubeInstance,startDate,endDate));
    }
 else {
      if (startDate == 0 && cubeInstance.getSegments().size() == 0) {
        startDate=cubeInstance.getDescriptor().getCubePartitionDesc().getPartitionDateStart();
      }
      CubeSegment lastSegment=null;
      for (      CubeSegment segment : cubeInstance.getSegments()) {
        if (segment.getDateRangeStart() == startDate) {
          segments.add(buildSegment(cubeInstance,startDate,endDate));
        }
        if (segment.getDateRangeStart() < startDate && startDate < segment.getDateRangeEnd()) {
          segments.add(buildSegment(cubeInstance,segment.getDateRangeStart(),startDate));
          segments.add(buildSegment(cubeInstance,startDate,endDate));
        }
        lastSegment=segment;
      }
      if (null == lastSegment || (lastSegment.getDateRangeEnd() == startDate)) {
        segments.add(buildSegment(cubeInstance,startDate,endDate));
      }
    }
  }
 else {
    segments.add(buildSegment(cubeInstance,0,0));
  }
  validateNewSegments(cubeInstance,buildType,segments);
  if (buildType == CubeBuildTypeEnum.MERGE) {
    CubeSegment newSeg=segments.get(0);
    List<CubeSegment> mergingSegments=cubeInstance.getMergingSegments(newSeg);
    this.makeDictForNewSegment(cubeInstance,newSeg,mergingSegments);
    this.makeSnapshotForNewSegment(newSeg,mergingSegments);
  }
 else   if (needMergeImmediately) {
    CubeSegment newSeg=segments.get(0);
    List<CubeSegment> mergingSegments=cubeInstance.getSegment(CubeSegmentStatusEnum.READY);
    this.makeDictForNewSegment(cubeInstance,newSeg,mergingSegments);
    this.makeSnapshotForNewSegment(newSeg,mergingSegments);
  }
  cubeInstance.getSegments().addAll(segments);
  Collections.sort(cubeInstance.getSegments());
  this.updateCube(cubeInstance);
  return segments;
}

{
  if (cubeInstance.getBuildingSegments().size() > 0) {
    throw new RuntimeException("There is already an allocating segment!");
  }
  List<CubeSegment> segments=new ArrayList<CubeSegment>();
  if (null != cubeInstance.getDescriptor().getCubePartitionDesc().getPartitionDateColumn()) {
    if (startDate == 0 && cubeInstance.getSegments().size() == 0) {
      startDate=cubeInstance.getDescriptor().getCubePartitionDesc().getPartitionDateStart();
    }
    CubeSegment lastSegment=null;
    for (    CubeSegment segment : cubeInstance.getSegments()) {
      if (segment.getDateRangeStart() == startDate) {
        segments.add(buildSegment(cubeInstance,startDate,endDate));
      }
      if (segment.getDateRangeStart() < startDate && startDate < segment.getDateRangeEnd()) {
        segments.add(buildSegment(cubeInstance,segment.getDateRangeStart(),startDate));
        segments.add(buildSegment(cubeInstance,startDate,endDate));
      }
      lastSegment=segment;
    }
    if (null == lastSegment || (lastSegment.getDateRangeEnd() == startDate)) {
      segments.add(buildSegment(cubeInstance,startDate,endDate));
    }
  }
 else {
    segments.add(buildSegment(cubeInstance,0,0));
  }
  validateNewSegments(cubeInstance,RealizationBuildTypeEnum.MERGE,segments);
  CubeSegment newSeg=segments.get(0);
  List<CubeSegment> mergingSegments=cubeInstance.getMergingSegments(newSeg);
  this.makeDictForNewSegment(cubeInstance,newSeg,mergingSegments);
  this.makeSnapshotForNewSegment(cubeInstance,newSeg,mergingSegments);
  cubeInstance.getSegments().addAll(segments);
  Collections.sort(cubeInstance.getSegments());
  this.updateCube(cubeInstance);
  return segments;
}

{
  CubeInstance cube=getCubeManager().getCube(cubeName);
  CubeDesc desc=cube.getDescriptor();
  if (desc.getRetentionRange() > 0) {
synchronized (CubeService.class) {
      cube=getCubeManager().getCube(cubeName);
      List<CubeSegment> readySegs=cube.getSegment(SegmentStatusEnum.READY);
      long currentRange=0;
      int position=readySegs.size() - 1;
      while (position >= 0) {
        currentRange+=(readySegs.get(position).getDateRangeEnd() - readySegs.get(position).getDateRangeStart());
        if (currentRange >= desc.getRetentionRange()) {
          break;
        }
        position--;
      }
      List<CubeSegment> toRemoveSegs=Lists.newArrayList();
      for (int i=0; i < position; i++) {
        toRemoveSegs.add(readySegs.get(i));
      }
      if (toRemoveSegs.size() > 0) {
        CubeUpdate cubeBuilder=new CubeUpdate(cube);
        cubeBuilder.setToRemoveSegs(toRemoveSegs.toArray(new CubeSegment[toRemoveSegs.size()]));
        try {
          this.getCubeManager().updateCube(cubeBuilder);
        }
 catch (        IOException e) {
          logger.error("Failed to remove old segment from cube " + cubeName,e);
        }
      }
    }
  }
}

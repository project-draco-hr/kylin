{
  CuboidScheduler scheduler=new CuboidScheduler(cube);
  long baseCuboid=Cuboid.getBaseCuboidId(cube);
  Collection<Long> cuboidSet=new TreeSet<Long>();
  cuboidSet.add(baseCuboid);
  LinkedList<Long> cuboidQueue=new LinkedList<Long>();
  cuboidQueue.push(baseCuboid);
  while (!cuboidQueue.isEmpty()) {
    long cuboid=cuboidQueue.pop();
    Collection<Long> spnanningCuboids=scheduler.getSpanningCuboid(cuboid);
    for (    Long sc : spnanningCuboids) {
      boolean notfound=cuboidSet.add(sc);
      if (!notfound) {
        throw new IllegalStateException("Find duplicate spanning cuboid " + sc + " from cuboid "+ cuboid);
      }
      cuboidQueue.push(sc);
    }
  }
  int mathCount=mathCalcCuboidCount(cube);
  if (mathCount != cuboidSet.size()) {
    throw new IllegalStateException("Math cuboid count " + mathCount + ", but actual cuboid count "+ cuboidSet.size());
  }
  return mathCount;
}

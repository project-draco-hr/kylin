{
  RegionScanner innerScanner=null;
  HRegion region=null;
  StringBuilder sb=new StringBuilder();
  byte[] allRows;
  try {
    this.serviceStartTime=System.currentTimeMillis();
    region=env.getRegion();
    region.startRegionOperation();
    final GTScanRequest scanReq=GTScanRequest.serializer.deserialize(ByteBuffer.wrap(HBaseZeroCopyByteString.zeroCopyGetBytes(request.getGtScanRequest())));
    final RawScan hbaseRawScan=RawScan.serializer.deserialize(ByteBuffer.wrap(HBaseZeroCopyByteString.zeroCopyGetBytes(request.getHbaseRawScan())));
    MassInTupleFilter.VALUE_PROVIDER_FACTORY=new MassInValueProviderFactoryImpl(new MassInValueProviderFactoryImpl.DimEncAware(){
      @Override public DimensionEncoding getDimEnc(      TblColRef col){
        return scanReq.getInfo().getCodeSystem().getDimEnc(col.getColumnDesc().getZeroBasedIndex());
      }
    }
);
    List<List<Integer>> hbaseColumnsToGT=Lists.newArrayList();
    for (    IntList intList : request.getHbaseColumnsToGTList()) {
      hbaseColumnsToGT.add(intList.getIntsList());
    }
    if (request.getRowkeyPreambleSize() - RowConstants.ROWKEY_CUBOIDID_LEN > 0) {
      updateRawScanByCurrentRegion(hbaseRawScan,region,request.getRowkeyPreambleSize() - RowConstants.ROWKEY_CUBOIDID_LEN);
    }
    Scan scan=CubeHBaseRPC.buildScan(hbaseRawScan);
    appendProfileInfo(sb);
    innerScanner=region.getScanner(scan);
    CoprocessorBehavior behavior=CoprocessorBehavior.valueOf(request.getBehavior());
    if (behavior.ordinal() < CoprocessorBehavior.SCAN.ordinal()) {
      List<Cell> temp=Lists.newArrayList();
      int counter=0;
      while (innerScanner.nextRaw(temp)) {
        counter++;
      }
      sb.append("Scanned " + counter + " rows in "+ (System.currentTimeMillis() - serviceStartTime)+ ",");
    }
    InnerScannerAsIterator cellListIterator=new InnerScannerAsIterator(innerScanner);
    if (behavior.ordinal() < CoprocessorBehavior.SCAN_FILTER_AGGR_CHECKMEM.ordinal()) {
      scanReq.setAggrCacheGB(0);
    }
    IGTStore store=new HBaseReadonlyStore(cellListIterator,scanReq,hbaseRawScan.hbaseColumns,hbaseColumnsToGT,request.getRowkeyPreambleSize());
    IGTScanner rawScanner=store.scan(scanReq);
    IGTScanner finalScanner=scanReq.decorateScanner(rawScanner,behavior.ordinal() >= CoprocessorBehavior.SCAN_FILTER.ordinal(),behavior.ordinal() >= CoprocessorBehavior.SCAN_FILTER_AGGR.ordinal());
    ByteBuffer buffer=ByteBuffer.allocate(RowConstants.ROWVALUE_BUFFER_SIZE);
    ByteArrayOutputStream outputStream=new ByteArrayOutputStream(RowConstants.ROWVALUE_BUFFER_SIZE);
    int finalRowCount=0;
    for (    GTRecord oneRecord : finalScanner) {
      buffer.clear();
      oneRecord.exportColumns(scanReq.getColumns(),buffer);
      buffer.flip();
      outputStream.write(buffer.array(),buffer.arrayOffset() - buffer.position(),buffer.remaining());
      finalRowCount++;
    }
    appendProfileInfo(sb);
    allRows=outputStream.toByteArray();
    byte[] compressedAllRows=CompressionUtils.compress(allRows);
    appendProfileInfo(sb);
    OperatingSystemMXBean operatingSystemMXBean=(OperatingSystemMXBean)ManagementFactory.getOperatingSystemMXBean();
    double systemCpuLoad=operatingSystemMXBean.getSystemCpuLoad();
    double freePhysicalMemorySize=operatingSystemMXBean.getFreePhysicalMemorySize();
    double freeSwapSpaceSize=operatingSystemMXBean.getFreeSwapSpaceSize();
    appendProfileInfo(sb);
    CubeVisitProtos.CubeVisitResponse.Builder responseBuilder=CubeVisitProtos.CubeVisitResponse.newBuilder();
    done.run(responseBuilder.setCompressedRows(HBaseZeroCopyByteString.wrap(compressedAllRows)).setStats(CubeVisitProtos.CubeVisitResponse.Stats.newBuilder().setAggregatedRowCount(finalScanner.getScannedRowCount() - finalRowCount).setScannedRowCount(finalScanner.getScannedRowCount()).setServiceStartTime(serviceStartTime).setServiceEndTime(System.currentTimeMillis()).setSystemCpuLoad(systemCpuLoad).setFreePhysicalMemorySize(freePhysicalMemorySize).setFreeSwapSpaceSize(freeSwapSpaceSize).setHostname(InetAddress.getLocalHost().getHostName()).setEtcMsg(sb.toString()).build()).build());
  }
 catch (  IOException ioe) {
    logger.error(ioe.toString());
    ResponseConverter.setControllerException(controller,ioe);
  }
 finally {
    IOUtils.closeQuietly(innerScanner);
    if (region != null) {
      try {
        region.closeRegionOperation();
      }
 catch (      IOException e) {
        e.printStackTrace();
        throw new RuntimeException(e);
      }
    }
  }
}

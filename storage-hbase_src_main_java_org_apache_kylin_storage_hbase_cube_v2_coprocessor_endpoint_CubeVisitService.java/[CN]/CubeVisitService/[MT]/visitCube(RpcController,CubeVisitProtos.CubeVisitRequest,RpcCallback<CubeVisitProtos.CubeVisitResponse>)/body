{
  List<RegionScanner> regionScanners=Lists.newArrayList();
  HRegion region=null;
  StringBuilder sb=new StringBuilder();
  byte[] allRows;
  String debugGitTag="";
  try {
    this.serviceStartTime=System.currentTimeMillis();
    region=env.getRegion();
    region.startRegionOperation();
    String serverPropString=request.getKylinProperties();
    Properties serverProp=new Properties();
    serverProp.load(new StringReader(serverPropString));
    KylinConfig.setKylinConfigInEnvIfMissing(serverProp);
    KylinConfig kylinConfig=KylinConfig.getInstanceFromEnv();
    debugGitTag=region.getTableDesc().getValue(IRealizationConstants.HTableGitTag);
    final GTScanRequest scanReq=GTScanRequest.serializer.deserialize(ByteBuffer.wrap(HBaseZeroCopyByteString.zeroCopyGetBytes(request.getGtScanRequest())));
    List<List<Integer>> hbaseColumnsToGT=Lists.newArrayList();
    for (    IntList intList : request.getHbaseColumnsToGTList()) {
      hbaseColumnsToGT.add(intList.getIntsList());
    }
    CoprocessorBehavior behavior=CoprocessorBehavior.valueOf(request.getBehavior());
    final List<RawScan> hbaseRawScans=deserializeRawScans(ByteBuffer.wrap(HBaseZeroCopyByteString.zeroCopyGetBytes(request.getHbaseRawScan())));
    appendProfileInfo(sb,"start latency: " + (this.serviceStartTime - request.getStartTime()));
    MassInTupleFilter.VALUE_PROVIDER_FACTORY=new MassInValueProviderFactoryImpl(new MassInValueProviderFactoryImpl.DimEncAware(){
      @Override public DimensionEncoding getDimEnc(      TblColRef col){
        return scanReq.getInfo().getCodeSystem().getDimEnc(col.getColumnDesc().getZeroBasedIndex());
      }
    }
);
    final List<InnerScannerAsIterator> cellListsForeachRawScan=Lists.newArrayList();
    for (    RawScan hbaseRawScan : hbaseRawScans) {
      if (request.getRowkeyPreambleSize() - RowConstants.ROWKEY_CUBOIDID_LEN > 0) {
        updateRawScanByCurrentRegion(hbaseRawScan,region,request.getRowkeyPreambleSize() - RowConstants.ROWKEY_CUBOIDID_LEN);
      }
      Scan scan=CubeHBaseRPC.buildScan(hbaseRawScan);
      RegionScanner innerScanner=region.getScanner(scan);
      regionScanners.add(innerScanner);
      InnerScannerAsIterator cellListIterator=new InnerScannerAsIterator(innerScanner);
      cellListsForeachRawScan.add(cellListIterator);
    }
    final Iterator<List<Cell>> allCellLists=Iterators.concat(cellListsForeachRawScan.iterator());
    if (behavior.ordinal() < CoprocessorBehavior.SCAN.ordinal()) {
      List<Cell> temp=Lists.newArrayList();
      int counter=0;
      for (      RegionScanner innerScanner : regionScanners) {
        while (innerScanner.nextRaw(temp)) {
          counter++;
        }
      }
      appendProfileInfo(sb,"scanned " + counter);
    }
    if (behavior.ordinal() < CoprocessorBehavior.SCAN_FILTER_AGGR_CHECKMEM.ordinal()) {
      scanReq.setAggCacheMemThreshold(0);
    }
    final MutableBoolean scanNormalComplete=new MutableBoolean(true);
    final long deadline=request.getTimeout() + this.serviceStartTime;
    final long storagePushDownLimit=scanReq.getStoragePushDownLimit();
    final CellListIterator cellListIterator=new CellListIterator(){
      int counter=0;
      @Override public void close() throws IOException {
        for (        CellListIterator closeable : cellListsForeachRawScan) {
          closeable.close();
        }
      }
      @Override public boolean hasNext(){
        if (counter > scanReq.getStorageScanRowNumThreshold()) {
          throw new GTScanExceedThresholdException("Exceed scan threshold at " + counter);
        }
        if (counter % 100000 == 1) {
          logger.info("Scanned " + counter + " rows from HBase.");
        }
        counter++;
        return allCellLists.hasNext();
      }
      @Override public List<Cell> next(){
        return allCellLists.next();
      }
      @Override public void remove(){
        throw new UnsupportedOperationException();
      }
    }
;
    IGTStore store=new HBaseReadonlyStore(cellListIterator,scanReq,hbaseRawScans.get(0).hbaseColumns,hbaseColumnsToGT,request.getRowkeyPreambleSize());
    IGTScanner rawScanner=store.scan(scanReq);
    IGTScanner finalScanner=scanReq.decorateScanner(rawScanner,behavior.ordinal() >= CoprocessorBehavior.SCAN_FILTER.ordinal(),behavior.ordinal() >= CoprocessorBehavior.SCAN_FILTER_AGGR.ordinal(),deadline);
    ByteBuffer buffer=ByteBuffer.allocate(BufferedMeasureEncoder.DEFAULT_BUFFER_SIZE);
    ByteArrayOutputStream outputStream=new ByteArrayOutputStream(BufferedMeasureEncoder.DEFAULT_BUFFER_SIZE);
    int finalRowCount=0;
    try {
      for (      GTRecord oneRecord : finalScanner) {
        if (finalRowCount > storagePushDownLimit) {
          logger.info("The finalScanner aborted because storagePushDownLimit is satisfied");
          break;
        }
        if (finalRowCount % 100000 == 1) {
          if (System.currentTimeMillis() > deadline) {
            throw new GTScanTimeoutException("finalScanner timeouts after scanned " + finalRowCount);
          }
        }
        buffer.clear();
        try {
          oneRecord.exportColumns(scanReq.getColumns(),buffer);
        }
 catch (        BufferOverflowException boe) {
          buffer=ByteBuffer.allocate(oneRecord.sizeOf(scanReq.getColumns()) * 2);
          oneRecord.exportColumns(scanReq.getColumns(),buffer);
        }
        outputStream.write(buffer.array(),0,buffer.position());
        finalRowCount++;
      }
    }
 catch (    GTScanTimeoutException e) {
      scanNormalComplete.setValue(false);
      logger.info("The cube visit did not finish normally because scan timeout",e);
    }
catch (    GTScanExceedThresholdException e) {
      scanNormalComplete.setValue(false);
      logger.info("The cube visit did not finish normally because scan num exceeds threshold",e);
    }
 finally {
      finalScanner.close();
    }
    appendProfileInfo(sb,"agg done");
    byte[] compressedAllRows;
    if (scanNormalComplete.booleanValue()) {
      allRows=outputStream.toByteArray();
    }
 else {
      allRows=new byte[0];
    }
    if (!kylinConfig.getCompressionResult()) {
      compressedAllRows=allRows;
    }
 else {
      compressedAllRows=CompressionUtils.compress(allRows);
    }
    appendProfileInfo(sb,"compress done");
    OperatingSystemMXBean operatingSystemMXBean=(OperatingSystemMXBean)ManagementFactory.getOperatingSystemMXBean();
    double systemCpuLoad=operatingSystemMXBean.getSystemCpuLoad();
    double freePhysicalMemorySize=operatingSystemMXBean.getFreePhysicalMemorySize();
    double freeSwapSpaceSize=operatingSystemMXBean.getFreeSwapSpaceSize();
    appendProfileInfo(sb,"server stats done");
    sb.append(" debugGitTag:" + debugGitTag);
    CubeVisitProtos.CubeVisitResponse.Builder responseBuilder=CubeVisitProtos.CubeVisitResponse.newBuilder();
    done.run(responseBuilder.setCompressedRows(HBaseZeroCopyByteString.wrap(compressedAllRows)).setStats(CubeVisitProtos.CubeVisitResponse.Stats.newBuilder().setAggregatedRowCount(finalScanner.getScannedRowCount() - finalRowCount).setScannedRowCount(finalScanner.getScannedRowCount()).setServiceStartTime(serviceStartTime).setServiceEndTime(System.currentTimeMillis()).setSystemCpuLoad(systemCpuLoad).setFreePhysicalMemorySize(freePhysicalMemorySize).setFreeSwapSpaceSize(freeSwapSpaceSize).setHostname(InetAddress.getLocalHost().getHostName()).setEtcMsg(sb.toString()).setNormalComplete(scanNormalComplete.booleanValue() ? 1 : 0).build()).build());
  }
 catch (  IOException ioe) {
    logger.error(ioe.toString(),ioe);
    IOException wrapped=new IOException("Error in coprocessor " + debugGitTag,ioe);
    ResponseConverter.setControllerException(controller,wrapped);
  }
catch (  OutOfMemoryError oom) {
    logger.error(oom.toString(),oom);
    IOException wrapped=new IOException("OOM in coprocessor " + debugGitTag,oom);
    ResponseConverter.setControllerException(controller,wrapped);
  }
 finally {
    for (    RegionScanner innerScanner : regionScanners) {
      IOUtils.closeQuietly(innerScanner);
    }
    if (region != null) {
      try {
        region.closeRegionOperation();
      }
 catch (      IOException e) {
        e.printStackTrace();
        throw new RuntimeException(e);
      }
    }
  }
}

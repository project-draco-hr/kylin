{
  JoinRelType joinType=JoinRelType.INNER;
  RexNode[] leftJoinKeysForIn=null;
  boolean isNotIn;
  boolean subqueryNeedsOuterJoin=bb.subqueryNeedsOuterJoin;
  SqlBasicCall call;
  SqlNode query;
  final RexNode expr=bb.mapSubqueryToExpr.get(node);
  if (expr != null) {
    return;
  }
  RelNode converted;
switch (node.getKind()) {
case CURSOR:
    convertCursor(bb,(SqlCall)node);
  return;
case MULTISET_QUERY_CONSTRUCTOR:
case MULTISET_VALUE_CONSTRUCTOR:
converted=convertMultisets(ImmutableList.of(node),bb);
break;
case IN:
call=(SqlBasicCall)node;
final SqlNode[] operands=call.getOperands();
isNotIn=((SqlInOperator)call.getOperator()).isNotIn();
SqlNode leftKeyNode=operands[0];
SqlNode seek=operands[1];
if ((leftKeyNode instanceof SqlCall) && (((SqlCall)leftKeyNode).getOperator() instanceof SqlRowOperator)) {
SqlBasicCall keyCall=(SqlBasicCall)leftKeyNode;
SqlNode[] keyCallOperands=keyCall.getOperands();
int rowLength=keyCallOperands.length;
leftJoinKeysForIn=new RexNode[rowLength];
for (int i=0; i < rowLength; i++) {
SqlNode sqlExpr=keyCallOperands[i];
leftJoinKeysForIn[i]=bb.convertExpression(sqlExpr);
}
}
 else {
leftJoinKeysForIn=new RexNode[1];
leftJoinKeysForIn[0]=bb.convertExpression(leftKeyNode);
}
if (seek instanceof SqlNodeList) {
SqlNodeList valueList=(SqlNodeList)seek;
boolean seenNull=false;
for (int i=0; i < valueList.size(); i++) {
SqlNode sqlNode=valueList.getList().get(i);
if (sqlNode instanceof SqlLiteral) {
SqlLiteral lit=(SqlLiteral)sqlNode;
if (lit.getValue() == null) {
seenNull=true;
}
}
}
if (!seenNull && (valueList.size() < getInSubqueryThreshold())) {
RexNode expression=convertInToOr(bb,leftJoinKeysForIn,valueList,isNotIn);
bb.mapSubqueryToExpr.put(node,expression);
return;
}
 else {
}
}
converted=convertExists(seek,true,false,subqueryNeedsOuterJoin || isNotIn);
if (subqueryNeedsOuterJoin || isNotIn) {
joinType=JoinRelType.LEFT;
}
 else {
joinType=JoinRelType.INNER;
}
break;
case EXISTS:
call=(SqlBasicCall)node;
query=call.getOperands()[0];
converted=convertExists(query,false,true,true);
if (convertNonCorrelatedSubq(call,bb,converted,true)) {
return;
}
joinType=JoinRelType.LEFT;
break;
case SCALAR_QUERY:
call=(SqlBasicCall)node;
query=call.getOperands()[0];
converted=convertExists(query,false,false,true);
if (convertNonCorrelatedSubq(call,bb,converted,false)) {
return;
}
converted=convertToSingleValueSubq(query,converted);
joinType=JoinRelType.LEFT;
break;
case SELECT:
converted=convertExists(node,false,false,true);
joinType=JoinRelType.LEFT;
break;
default :
throw Util.newInternal("unexpected kind of subquery :" + node);
}
final RexNode expression=bb.register(converted,joinType,leftJoinKeysForIn);
bb.mapSubqueryToExpr.put(node,expression);
}

{
  List<StreamingMessage> result=Lists.newLinkedList();
  try {
    long startTimestamp=timeRange.getFirst() - margin;
    long offset=KafkaUtils.findClosestOffsetWithDataTimestamp(kafkaClusterConfig,partitionId,startTimestamp,streamingParser);
    int fetchRound=0;
    int consumeMsgCount=0;
    Broker leadBroker=null;
    String topic=kafkaClusterConfig.getTopic();
    while (true) {
      boolean outOfMargin=false;
      int consumeMsgCountAtBeginning=consumeMsgCount;
      fetchRound++;
      if (leadBroker == null) {
        leadBroker=getLeadBroker();
      }
      if (leadBroker == null) {
        logger.warn("cannot find lead broker, wait 5s");
        Thread.sleep(5000);
        continue;
      }
      logger.info("fetching topic {} partition id {} offset {} leader {}",topic,String.valueOf(partitionId),String.valueOf(offset),leadBroker.toString());
      final FetchResponse fetchResponse=KafkaRequester.fetchResponse(topic,partitionId,offset,leadBroker,kafkaClusterConfig);
      if (fetchResponse.errorCode(topic,partitionId) != 0) {
        logger.warn("fetch response offset:" + offset + " errorCode:"+ fetchResponse.errorCode(topic,partitionId));
        Thread.sleep(30000);
        continue;
      }
      for (      MessageAndOffset messageAndOffset : fetchResponse.messageSet(topic,partitionId)) {
        offset++;
        consumeMsgCount++;
        final StreamingMessage streamingMessage=streamingParser.parse(messageAndOffset);
        if (streamingParser.filter(streamingMessage)) {
          final long timestamp=streamingMessage.getTimestamp();
          if (timestamp >= timeRange.getFirst() && timestamp < timeRange.getSecond()) {
            result.add(streamingMessage);
          }
 else           if (timestamp < timeRange.getSecond() + margin) {
          }
 else {
            logger.info("thread:" + Thread.currentThread() + " message timestamp:"+ timestamp+ " is out of time range:"+ timeRange+ " margin:"+ margin);
            outOfMargin=true;
            break;
          }
        }
      }
      logger.info("Number of messages consumed: " + consumeMsgCount + " offset is: "+ offset+ " total fetch round: "+ fetchRound);
      if (outOfMargin) {
        break;
      }
      if (consumeMsgCount == consumeMsgCountAtBeginning) {
        logger.info("no message consumed this round, wait 30s");
        Thread.sleep(30000);
      }
    }
  }
 catch (  InterruptedException e) {
    logger.warn("this thread should not be interrupted, just stop fetching",e);
  }
  return result;
}

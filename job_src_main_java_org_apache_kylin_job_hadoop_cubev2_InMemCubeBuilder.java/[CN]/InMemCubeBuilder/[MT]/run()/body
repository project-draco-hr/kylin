{
  try {
    logger.info("Create base cuboid " + baseCuboidId);
    final GridTable baseCuboidGT=newGridTableByCuboidID(baseCuboidId,true);
    GTBuilder baseGTBuilder=baseCuboidGT.rebuild();
    final GTRecord baseGTRecord=new GTRecord(baseCuboidGT.getInfo());
    IGTScanner queueScanner=new IGTScanner(){
      @Override public Iterator<GTRecord> iterator(){
        return new Iterator<GTRecord>(){
          List<String> currentObject=null;
          @Override public boolean hasNext(){
            try {
              currentObject=queue.take();
            }
 catch (            InterruptedException e) {
              throw new RuntimeException(e);
            }
            return currentObject != null && currentObject.size() > 0;
          }
          @Override public GTRecord next(){
            if (currentObject.size() == 0)             throw new IllegalStateException();
            buildGTRecord(currentObject,baseGTRecord);
            return baseGTRecord;
          }
          @Override public void remove(){
            throw new UnsupportedOperationException();
          }
        }
;
      }
      @Override public void close() throws IOException {
      }
      @Override public GTInfo getInfo(){
        return baseCuboidGT.getInfo();
      }
      @Override public int getScannedRowCount(){
        return 0;
      }
      @Override public int getScannedRowBlockCount(){
        return 0;
      }
    }
;
    Pair<BitSet,BitSet> dimensionMetricsBitSet=getDimensionAndMetricColumnBitSet(baseCuboidId);
    GTScanRequest req=new GTScanRequest(baseCuboidGT.getInfo(),null,dimensionMetricsBitSet.getFirst(),dimensionMetricsBitSet.getSecond(),metricsAggrFuncs,null);
    IGTScanner aggregationScanner=new GTAggregateScanner(queueScanner,req);
    int counter=0;
    for (    GTRecord r : aggregationScanner) {
      baseGTBuilder.write(r);
      counter++;
    }
    baseGTBuilder.close();
    aggregationScanner.close();
    logger.info("Base cuboid has " + counter + " rows;");
    SimpleGridTableTree tree=new SimpleGridTableTree();
    tree.data=baseCuboidGT;
    tree.id=baseCuboidId;
    tree.parent=null;
    if (counter > 0) {
      List<Long> children=cuboidScheduler.getSpanningCuboid(baseCuboidId);
      Collections.sort(children);
      for (      Long childId : children) {
        createNDCuboidGT(tree,baseCuboidId,childId);
      }
    }
    baseCuboidGT.getStore().drop();
  }
 catch (  IOException e) {
    logger.error("Fail to build cube",e);
    throw new RuntimeException(e);
  }
}

{
  final List<BuildCubeJob> buildCubeJobs=listAllCubingJobs(cube.getName(),null,EnumSet.allOf(ExecutableState.class));
  for (  BuildCubeJob job : buildCubeJobs) {
    if (job.getStatus() == ExecutableState.READY || job.getStatus() == ExecutableState.RUNNING) {
      throw new JobException("The cube " + cube.getName() + " has running job("+ job.getId()+ ") please discard it and try again.");
    }
  }
  try {
    List<CubeSegment> cubeSegments;
    if (buildType == CubeBuildTypeEnum.BUILD) {
      cubeSegments=this.getCubeManager().appendSegments(cube,startDate,endDate);
    }
 else     if (buildType == CubeBuildTypeEnum.MERGE) {
      cubeSegments=this.getCubeManager().mergeSegments(cube,startDate,endDate);
    }
 else {
      throw new JobException("invalid build type:" + buildType);
    }
    Preconditions.checkState(cubeSegments.size() == 1,"can only allocate one segment");
    CubeSegment segment=cubeSegments.get(0);
    BuildCubeJobBuilder builder=BuildCubeJobBuilder.newBuilder(new JobEngineConfig(getConfig()),segment);
    final BuildCubeJob job=builder.build();
    segment.setLastBuildJobID(job.getId());
    getCubeManager().updateCube(cube);
    getExecutableManager().addJob(job);
    return parseToJobInstance(job);
  }
 catch (  CubeIntegrityException e) {
    throw new InternalErrorException(e.getLocalizedMessage(),e);
  }
}

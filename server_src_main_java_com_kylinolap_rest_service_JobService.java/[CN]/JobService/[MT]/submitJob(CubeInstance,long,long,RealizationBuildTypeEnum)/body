{
  List<JobInstance> jobInstances=this.getJobManager().listJobs(cube.getName(),null);
  for (  JobInstance jobInstance : jobInstances) {
    if (jobInstance.getStatus() == JobStatusEnum.PENDING || jobInstance.getStatus() == JobStatusEnum.RUNNING) {
      throw new JobException("The cube " + cube.getName() + " has running job("+ jobInstance.getUuid()+ ") please discard it and try again.");
    }
  }
  String uuid=null;
  try {
    List<CubeSegment> cubeSegments;
    if (buildType == RealizationBuildTypeEnum.BUILD) {
      cubeSegments=this.getCubeManager().appendSegments(cube,startDate,endDate);
    }
 else     if (buildType == RealizationBuildTypeEnum.MERGE) {
      cubeSegments=this.getCubeManager().mergeSegments(cube,startDate,endDate);
    }
 else {
      throw new JobException("invalid build type:" + buildType);
    }
    List<JobInstance> jobs=Lists.newArrayListWithExpectedSize(cubeSegments.size());
    for (    CubeSegment segment : cubeSegments) {
      uuid=segment.getUuid();
      JobInstance job=this.getJobManager().createJob(cube.getName(),segment.getName(),segment.getUuid(),buildType);
      segment.setLastBuildJobID(uuid);
      jobs.add(job);
    }
    getCubeManager().updateCube(cube);
    for (    JobInstance job : jobs) {
      this.getJobManager().submitJob(job);
      permissionService.init(job,null);
      permissionService.inherit(job,cube);
    }
  }
 catch (  CubeIntegrityException e) {
    throw new InternalErrorException(e.getLocalizedMessage(),e);
  }
  return uuid;
}

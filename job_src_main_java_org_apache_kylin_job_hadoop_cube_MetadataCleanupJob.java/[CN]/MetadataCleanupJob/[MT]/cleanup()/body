{
  CubeManager cubeManager=CubeManager.getInstance(config);
  Set<String> activeResourceList=Sets.newHashSet();
  for (  org.apache.kylin.cube.CubeInstance cube : cubeManager.listAllCubes()) {
    for (    org.apache.kylin.cube.CubeSegment segment : cube.getSegments()) {
      activeResourceList.addAll(segment.getSnapshotPaths());
      activeResourceList.addAll(segment.getDictionaryPaths());
    }
  }
  List<String> toDeleteResource=Lists.newArrayList();
  for (  String resourceRoot : new String[]{ResourceStore.SNAPSHOT_RESOURCE_ROOT}) {
    ArrayList<String> snapshotTables=getStore().listResources(resourceRoot);
    if (snapshotTables != null) {
      for (      String snapshotTable : snapshotTables) {
        ArrayList<String> snapshotNames=getStore().listResources(snapshotTable);
        if (snapshotNames != null)         for (        String snapshot : snapshotNames) {
          if (!activeResourceList.contains(snapshot)) {
            long ts=getStore().getResourceTimestamp(snapshot);
            if (isOlderThanThreshold(ts))             toDeleteResource.add(snapshot);
          }
        }
      }
    }
  }
  ArrayList<String> dictTables=getStore().listResources(ResourceStore.DICT_RESOURCE_ROOT);
  if (dictTables != null) {
    for (    String table : dictTables) {
      ArrayList<String> tableColNames=getStore().listResources(table);
      if (tableColNames != null)       for (      String tableCol : tableColNames) {
        ArrayList<String> dictionaries=getStore().listResources(tableCol);
        if (dictionaries != null)         for (        String dict : dictionaries)         if (!activeResourceList.contains(dict)) {
          long ts=getStore().getResourceTimestamp(dict);
          if (isOlderThanThreshold(ts))           toDeleteResource.add(dict);
        }
      }
    }
  }
  ExecutableDao executableDao=ExecutableDao.getInstance(KylinConfig.getInstanceFromEnv());
  List<ExecutablePO> allExecutable=executableDao.getJobs();
  for (  ExecutablePO executable : allExecutable) {
    long lastModified=executable.getLastModified();
    ExecutableOutputPO output=executableDao.getJobOutput(executable.getUuid());
    if (System.currentTimeMillis() - lastModified > TIME_THREADSHOLD_FOR_JOB && (output.getStatus().equals(JobStatusEnum.FINISHED.toString()) || output.getStatus().equals(JobStatusEnum.DISCARDED.toString()))) {
      toDeleteResource.add(ResourceStore.EXECUTE_PATH_ROOT + "/" + executable.getUuid());
      toDeleteResource.add(ResourceStore.EXECUTE_OUTPUT_ROOT + "/" + executable.getUuid());
      for (      ExecutablePO task : executable.getTasks()) {
        toDeleteResource.add(ResourceStore.EXECUTE_PATH_ROOT + "/" + task.getUuid());
        toDeleteResource.add(ResourceStore.EXECUTE_OUTPUT_ROOT + "/" + task.getUuid());
      }
    }
  }
  if (toDeleteResource.size() > 0) {
    logger.info("The following resources have no reference or is too old, will be cleaned from metadata store: \n");
    for (    String s : toDeleteResource) {
      logger.info(s);
      if (delete == true) {
        getStore().deleteResource(s);
      }
    }
  }
 else {
    logger.info("No resource to be cleaned up from metadata store;");
  }
}

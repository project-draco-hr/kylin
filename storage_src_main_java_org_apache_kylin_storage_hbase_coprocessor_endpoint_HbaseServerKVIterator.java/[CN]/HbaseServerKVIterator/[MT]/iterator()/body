{
  return new Iterator<KeyValuePair>(){
    ImmutableBytesWritable key=new ImmutableBytesWritable();
    ImmutableBytesWritable value=new ImmutableBytesWritable();
    ImmutableBytesWritable dict=new ImmutableBytesWritable();
    KeyValuePair pair=new KeyValuePair(key,value);
    private boolean hasMore=true;
    @Override public boolean hasNext(){
      return hasMore;
    }
    @Override public KeyValuePair next(){
      if (hasNext()) {
        try {
          hasMore=innerScanner.nextRaw(results);
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
        if (results.size() < 1)         throw new IllegalStateException("Hbase row contains less than 1 cell");
        Dictionary<?> dictionary=null;
        boolean hasDictData=false;
        for (        Cell c : results) {
          if (BytesUtil.compareBytes(IIDesc.HBASE_QUALIFIER_BYTES,0,c.getQualifierArray(),c.getQualifierOffset(),IIDesc.HBASE_QUALIFIER_BYTES.length) == 0) {
            key.set(c.getRowArray(),c.getRowOffset(),c.getRowLength());
            value.set(c.getValueArray(),c.getValueOffset(),c.getValueLength());
          }
 else           if (BytesUtil.compareBytes(IIDesc.HBASE_DICTIONARY_BYTES,0,c.getQualifierArray(),c.getQualifierOffset(),IIDesc.HBASE_DICTIONARY_BYTES.length) == 0) {
            dict.set(c.getValueArray(),c.getValueOffset(),c.getValueLength());
            hasDictData=true;
          }
        }
        if (hasDictData) {
          try {
            final DataInputStream in=new DataInputStream(new ByteArrayInputStream(dict.get(),dict.getOffset(),dict.getLength()));
            String type=in.readUTF();
            dictionary=(Dictionary<?>)ClassUtil.forName(type,Dictionary.class).newInstance();
            dictionary.readFields(in);
          }
 catch (          Exception e) {
            logger.error("error create dictionary",e);
          }
        }
        pair.setDictionary(dictionary);
        results.clear();
        return pair;
      }
 else {
        return null;
      }
    }
    @Override public void remove(){
      throw new UnsupportedOperationException();
    }
  }
;
}

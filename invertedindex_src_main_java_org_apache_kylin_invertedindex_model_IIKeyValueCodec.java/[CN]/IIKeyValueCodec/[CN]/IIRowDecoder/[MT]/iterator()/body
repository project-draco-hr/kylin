{
  return new Iterator<Slice>(){
    @Override public boolean hasNext(){
      return iterator.hasNext();
    }
    @Override public Slice next(){
      int columns=0;
      ColumnValueContainer[] valueContainers=new ColumnValueContainer[incompleteDigest.getColumnCount()];
      Map<Integer,Dictionary<?>> localDictionaries=Maps.newHashMap();
      boolean firstTime=true;
      short curShard=0;
      long curTimestamp=0;
      short lastShard=0;
      long lastTimestamp=0;
      while (iterator.hasNext() && columns < incompleteDigest.getColumnCount()) {
        final IIRow row=iterator.next();
        final ImmutableBytesWritable key=row.getKey();
        int i=key.getOffset();
        curShard=(short)BytesUtil.readUnsigned(key.get(),i,SHARD_LEN);
        i+=SHARD_LEN;
        curTimestamp=BytesUtil.readLong(key.get(),i,TIMEPART_LEN);
        i+=TIMEPART_LEN;
        if (!firstTime) {
          Preconditions.checkArgument(curShard == lastShard,"shard should be equals in one slice, curShard is" + curShard + " lastShard is "+ lastShard);
          Preconditions.checkArgument(curTimestamp == lastTimestamp,"timestamp should be equals in one slice, curTimestamp is" + curTimestamp + " lastTimestamp is "+ lastTimestamp);
        }
        int curCol=BytesUtil.readUnsigned(key.get(),i,COLNO_LEN);
        if (incompleteDigest.isMetrics(curCol)) {
          CompressedValueContainer c=new CompressedValueContainer(incompleteDigest,curCol,0);
          c.fromBytes(row.getValue());
          valueContainers[curCol]=c;
        }
 else {
          final Dictionary<?> dictionary=deserialize(row.getDictionary());
          CompressedValueContainer c=new CompressedValueContainer(dictionary.getSizeOfId(),dictionary.getMaxId() - dictionary.getMinId() + 1,0);
          c.fromBytes(row.getValue());
          valueContainers[curCol]=c;
          localDictionaries.put(curCol,dictionary);
        }
        columns++;
        lastShard=curShard;
        lastTimestamp=curTimestamp;
        firstTime=false;
      }
      Preconditions.checkArgument(columns == incompleteDigest.getColumnCount(),"column count is " + columns + " should be equals to incompleteDigest.getColumnCount() "+ incompleteDigest.getColumnCount());
      TableRecordInfoDigest digest=createDigest(columns,incompleteDigest.getIsMetric(),incompleteDigest.getMetricDataTypes(),localDictionaries);
      Slice slice=new Slice(digest,curShard,curTimestamp,valueContainers);
      slice.setLocalDictionaries(localDictionaries);
      return slice;
    }
    @Override public void remove(){
      throw new UnsupportedOperationException();
    }
  }
;
}

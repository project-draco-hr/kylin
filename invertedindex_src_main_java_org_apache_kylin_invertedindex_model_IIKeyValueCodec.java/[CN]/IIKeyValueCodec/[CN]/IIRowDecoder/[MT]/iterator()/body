{
  return new Iterator<Slice>(){
    @Override public boolean hasNext(){
      return iterator.hasNext();
    }
    @Override public Slice next(){
      int columns=0;
      ColumnValueContainer[] valueContainers=new ColumnValueContainer[digest.getColumnCount()];
      Map<Integer,Dictionary<?>> localDictionaries=Maps.newHashMap();
      boolean firstTime=true;
      short curShard=0;
      long curTimestamp=0;
      short lastShard=0;
      long lastTimestamp=0;
      while (iterator().hasNext() && columns < digest.getColumnCount()) {
        final IIRow row=iterator.next();
        final ImmutableBytesWritable key=row.getKey();
        int i=key.getOffset();
        curShard=(short)BytesUtil.readUnsigned(key.get(),i,SHARD_LEN);
        i+=SHARD_LEN;
        curTimestamp=BytesUtil.readLong(key.get(),i,TIMEPART_LEN);
        i+=TIMEPART_LEN;
        if (!firstTime) {
          Preconditions.checkArgument(curShard == lastShard,"shard should be equals in one slice, curShard is" + curShard + " lastShard is "+ lastShard);
          Preconditions.checkArgument(curTimestamp == lastTimestamp,"timestamp should be equals in one slice, curTimestamp is" + curTimestamp + " lastTimestamp is "+ lastTimestamp);
        }
        int curCol=BytesUtil.readUnsigned(key.get(),i,COLNO_LEN);
        CompressedValueContainer c=new CompressedValueContainer(digest,curCol,0);
        c.fromBytes(row.getValue());
        valueContainers[curCol]=c;
        localDictionaries.put(curCol,deserialize(row.getDictionary()));
        columns++;
        lastShard=curShard;
        lastTimestamp=curTimestamp;
        firstTime=false;
      }
      Preconditions.checkArgument(columns == digest.getColumnCount(),"column count is " + columns + " should be equals to digest.getColumnCount() "+ digest.getColumnCount());
      Slice slice=new Slice(digest,curShard,curTimestamp,valueContainers);
      slice.setLocalDictionaries(localDictionaries);
      return slice;
    }
    @Override public void remove(){
      throw new UnsupportedOperationException();
    }
  }
;
}

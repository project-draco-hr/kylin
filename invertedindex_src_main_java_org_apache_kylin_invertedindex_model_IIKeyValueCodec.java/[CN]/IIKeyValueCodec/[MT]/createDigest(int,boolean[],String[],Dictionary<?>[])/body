{
  int[] dictMaxIds=new int[nColumns];
  int[] lengths=new int[nColumns];
  final boolean emptyDictionary=Array.isEmpty(dictionaries);
  for (int i=0; i < nColumns; ++i) {
    if (isMetric[i]) {
      final FixedLenMeasureCodec<?> fixedLenMeasureCodec=FixedLenMeasureCodec.get(DataType.getInstance(dataTypes[i]));
      lengths[i]=fixedLenMeasureCodec.getLength();
    }
 else {
      if (emptyDictionary) {
        final DataType dataType=DataType.getInstance(dataTypes[i]);
        if (dataType.isNumberFamily()) {
          lengths[i]=16;
        }
 else         if (dataType.isStringFamily()) {
          lengths[i]=256;
        }
 else         if (dataType.isDateTimeFamily()) {
          lengths[i]=19;
        }
 else {
          throw new RuntimeException("invalid data type:" + dataType);
        }
        dictMaxIds[i]=Integer.MAX_VALUE;
      }
 else {
        final Dictionary<?> dictionary=dictionaries[i];
        lengths[i]=dictionary.getSizeOfId();
        dictMaxIds[i]=dictionary.getMaxId();
      }
    }
  }
  int pos=0;
  int[] offsets=new int[nColumns];
  for (int i=0; i < nColumns; i++) {
    offsets[i]=pos;
    pos+=lengths[i];
  }
  int byteFormLen=pos;
  return new TableRecordInfoDigest(nColumns,byteFormLen,offsets,dictMaxIds,lengths,isMetric,dataTypes);
}

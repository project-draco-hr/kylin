{
  MeasureDesc desc=cubeDesc.getMeasures().get(measureIdx);
  FunctionDesc func=desc.getFunction();
  ParameterDesc paramDesc=func.getParameter();
  int[] flatTableIdx=intermediateTableDesc.getMeasureColumnIndexes()[measureIdx];
  byte[] result=null;
  if (flatTableIdx == null) {
    result=Bytes.toBytes(paramDesc.getValue());
  }
 else   if (func.isCount() || func.isHolisticCountDistinct()) {
    result=ONE;
  }
 else   if (func.isTopN()) {
    int keyColIndex=flatTableIdx[flatTableIdx.length - 1];
    Dictionary<String> literalColDict=topNLiteralColDictMap.get(keyColIndex);
    int keyColEncoded=literalColDict.getIdFromValue(Bytes.toString(splitBuffers[keyColIndex].value));
    valueBuf.clear();
    valueBuf.putInt(literalColDict.getSizeOfId());
    valueBuf.putInt(keyColEncoded);
    if (flatTableIdx.length == 1) {
      valueBuf.putDouble(1.0);
    }
 else {
      valueBuf.putDouble(Double.valueOf(Bytes.toString(splitBuffers[flatTableIdx[0]].value)));
    }
    result=valueBuf.array();
  }
 else {
    for (int i=0; i < flatTableIdx.length; i++) {
      SplittedBytes split=splitBuffers[flatTableIdx[i]];
      if (result == null) {
        result=Arrays.copyOf(split.value,split.length);
      }
 else {
        byte[] newResult=new byte[result.length + split.length];
        System.arraycopy(result,0,newResult,0,result.length);
        System.arraycopy(split.value,0,newResult,result.length,split.length);
        result=newResult;
      }
    }
  }
  if (isNull(result)) {
    result=null;
  }
  return result;
}

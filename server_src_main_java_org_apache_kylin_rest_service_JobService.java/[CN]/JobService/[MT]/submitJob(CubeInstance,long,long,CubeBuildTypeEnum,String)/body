{
  final List<CubingJob> cubingJobs=listAllCubingJobs(cube.getName(),null,EnumSet.allOf(ExecutableState.class));
  for (  CubingJob job : cubingJobs) {
    if (job.getStatus() == ExecutableState.READY || job.getStatus() == ExecutableState.RUNNING || job.getStatus() == ExecutableState.ERROR) {
      throw new JobException("The cube " + cube.getName() + " has running job("+ job.getId()+ ") please discard it and try again.");
    }
  }
  CubingJob job;
  CubingJobBuilder builder=new CubingJobBuilder(new JobEngineConfig(getConfig()));
  builder.setSubmitter(submitter);
  if (buildType == CubeBuildTypeEnum.BUILD) {
    if (cube.getDescriptor().hasHolisticCountDistinctMeasures() && cube.getSegments().size() > 0) {
      Pair<CubeSegment,CubeSegment> segs=getCubeManager().appendAndMergeSegments(cube,endDate);
      job=builder.buildAndMergeJob(segs.getFirst(),segs.getSecond());
    }
 else {
      CubeSegment newSeg=getCubeManager().appendSegments(cube,endDate);
      job=builder.buildJob(newSeg);
    }
  }
 else   if (buildType == CubeBuildTypeEnum.MERGE) {
    CubeSegment newSeg=getCubeManager().mergeSegments(cube,startDate,endDate);
    job=builder.mergeJob(newSeg);
  }
 else   if (buildType == CubeBuildTypeEnum.REFRESH) {
    CubeSegment refreshSeg=getCubeManager().refreshSegment(cube,startDate,endDate);
    job=builder.buildJob(refreshSeg);
  }
 else {
    throw new JobException("invalid build type:" + buildType);
  }
  getExecutableManager().addJob(job);
  JobInstance jobInstance=getSingleJobInstance(job);
  accessService.init(jobInstance,null);
  accessService.inherit(jobInstance,cube);
  return jobInstance;
}

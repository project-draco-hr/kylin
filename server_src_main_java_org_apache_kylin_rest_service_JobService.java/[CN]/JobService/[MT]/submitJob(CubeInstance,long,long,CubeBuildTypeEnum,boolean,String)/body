{
  checkCubeDescSignature(cube);
  checkNoRunningJob(cube);
  DefaultChainedExecutable job;
  if (buildType == CubeBuildTypeEnum.BUILD) {
    CubeSegment newSeg=getCubeManager().appendSegments(cube,endDate);
    job=EngineFactory.createBatchCubingJob(newSeg,submitter);
  }
 else   if (buildType == CubeBuildTypeEnum.MERGE) {
    CubeSegment newSeg=getCubeManager().mergeSegments(cube,startDate,endDate,forceMergeEmptySeg);
    job=EngineFactory.createBatchMergeJob(newSeg,submitter);
  }
 else   if (buildType == CubeBuildTypeEnum.REFRESH) {
    List<CubeSegment> readySegs=cube.getSegments(SegmentStatusEnum.READY);
    boolean segExists=false;
    for (    CubeSegment aSeg : readySegs) {
      if (aSeg.getDateRangeStart() == startDate && aSeg.getDateRangeEnd() == endDate) {
        segExists=true;
        break;
      }
    }
    if (segExists == false) {
      throw new IllegalArgumentException("You can only refresh an existing segment, but there is no ready segment for start time:" + startDate + ", end time: "+ endDate);
    }
    CubeSegment refreshSeg=getCubeManager().refreshSegment(cube,startDate,endDate);
    job=EngineFactory.createBatchCubingJob(refreshSeg,submitter);
  }
 else {
    throw new JobException("invalid build type:" + buildType);
  }
  getExecutableManager().addJob(job);
  JobInstance jobInstance=getSingleJobInstance(job);
  accessService.init(jobInstance,null);
  accessService.inherit(jobInstance,cube);
  return jobInstance;
}

{
  boolean needUpdateCache=true;
  final StreamSQLDigest streamSQLDigest=new StreamSQLDigest(sqlDigest,partitionColRef);
  StreamSQLResult cachedResult=null;
  Element element=cacheManager.getCache(STORAGE_LAYER_TUPLE_CACHE).get(streamSQLDigest);
  if (element != null) {
    cachedResult=(StreamSQLResult)element.getObjectValue();
  }
  Range<Long> ts=TsConditionExtractor.extractTsCondition(partitionColRef,sqlDigest.filter);
  if (ts == null || ts.isEmpty()) {
    logger.info("ts range in the query conflicts,return empty directly");
    return ITupleIterator.EMPTY_TUPLE_ITERATOR;
  }
  final Range<Long> tsRange=ts;
  ITupleIterator ret=null;
  if (cachedResult != null) {
    logger.debug("existing cache    : " + cachedResult);
    Range<Long> reusePeriod=cachedResult.getReusableResults(tsRange);
    logger.info("ts Range in query: " + RangeUtil.formatTsRange(tsRange));
    logger.info("potential reusable range   : " + RangeUtil.formatTsRange(reusePeriod));
    if (reusePeriod != null) {
      List<Range<Long>> remainings=RangeUtil.remove(tsRange,reusePeriod);
      if (remainings.size() == 1) {
        SimpleTupleIterator reusedTuples=new SimpleTupleIterator(cachedResult.reuse(reusePeriod));
        Range<Long> remaining=remainings.get(0);
        ITupleIterator freshTuples=SQLDigestUtil.appendTsFilterToExecute(sqlDigest,partitionColRef,remaining,new Function<Void,ITupleIterator>(){
          @Override public ITupleIterator apply(          Void input){
            return StorageEngineFactory.getStorageEngine(realization,false).search(context,sqlDigest);
          }
        }
);
        ret=new CompoundTupleIterator(Lists.newArrayList(reusedTuples,freshTuples));
      }
 else       if (remainings.size() == 0) {
        needUpdateCache=false;
        ret=new SimpleTupleIterator(cachedResult.reuse(reusePeriod));
      }
    }
  }
  if (ret == null) {
    logger.info("decision: not using cache");
    ret=StorageEngineFactory.getStorageEngine(realization,false).search(context,sqlDigest);
  }
 else {
    logger.info("decision: use cache");
  }
  if (needUpdateCache) {
    ITupleIterator tee=new TeeTupleIterator(ret,new Function<List<ITuple>,Void>(){
      @Nullable @Override public Void apply(      List<ITuple> input){
        StreamSQLResult newCacheEntry=new StreamSQLResult(input,tsRange,partitionColRef);
        cacheManager.getCache(STORAGE_LAYER_TUPLE_CACHE).put(new Element(streamSQLDigest,newCacheEntry));
        logger.debug("current cache: " + newCacheEntry);
        return null;
      }
    }
);
    return tee;
  }
 else {
    return ret;
  }
}

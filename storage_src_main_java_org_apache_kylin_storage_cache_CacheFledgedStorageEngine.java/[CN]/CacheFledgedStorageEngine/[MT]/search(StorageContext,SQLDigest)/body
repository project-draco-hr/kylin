{
  boolean needUpdateCache=sqlDigest.groupbyColumns.contains(partitionColRef);
  final StreamSQLDigest streamSQLDigest=new StreamSQLDigest(sqlDigest,partitionColRef);
  StreamSQLResult cachedResult=null;
  Cache cache=cacheManager.getCache(STORAGE_LAYER_TUPLE_CACHE);
  Element element=cache.get(streamSQLDigest);
  if (element != null) {
    cachedResult=(StreamSQLResult)element.getObjectValue();
  }
  Range<Long> ts=TsConditionExtractor.extractTsCondition(partitionColRef,sqlDigest.filter);
  if (ts == null || ts.isEmpty()) {
    logger.info("ts range in the query conflicts,return empty directly");
    return ITupleIterator.EMPTY_TUPLE_ITERATOR;
  }
  ITupleIterator ret=null;
  if (cachedResult != null) {
    logger.debug("existing cache    : " + cachedResult);
    Range<Long> reusePeriod=cachedResult.getReusableResults(ts);
    logger.info("ts Range in query: " + RangeUtil.formatTsRange(ts));
    logger.info("potential reusable range   : " + RangeUtil.formatTsRange(reusePeriod));
    if (reusePeriod != null) {
      List<Range<Long>> remainings=RangeUtil.remove(ts,reusePeriod);
      if (remainings.size() == 1) {
        SimpleTupleIterator reusedTuples=new SimpleTupleIterator(cachedResult.reuse(reusePeriod));
        Range<Long> remaining=remainings.get(0);
        logger.info("Appending ts " + RangeUtil.formatTsRange(remaining) + " as additional filter");
        ITupleIterator freshTuples=SQLDigestUtil.appendTsFilterToExecute(sqlDigest,partitionColRef,remaining,new Function<Void,ITupleIterator>(){
          @Override public ITupleIterator apply(          Void input){
            return StorageEngineFactory.getStorageEngine(realization,false).search(context,sqlDigest);
          }
        }
);
        ret=new CompoundTupleIterator(Lists.newArrayList(reusedTuples,freshTuples));
      }
 else       if (remainings.size() == 0) {
        needUpdateCache=false;
        ret=new SimpleTupleIterator(cachedResult.reuse(reusePeriod));
      }
    }
  }
 else {
    logger.info("no cache entry for this query");
  }
  if (ret == null) {
    logger.info("decision: not using cache");
    ret=StorageEngineFactory.getStorageEngine(realization,false).search(context,sqlDigest);
  }
 else {
    logger.info("decision: use cache");
  }
  if (needUpdateCache) {
    final Range<Long> finalTs=ts;
    final TeeTupleIterator tee=new TeeTupleIterator(ret);
    tee.setActionOnSeeingWholeData(new Function<List<ITuple>,Void>(){
      @Nullable @Override public Void apply(      List<ITuple> input){
        Range<Long> tsRange=finalTs;
        Range<Long> cacheExclude=tee.getCacheExcludedPeriod();
        if (cacheExclude != null) {
          List<Range<Long>> cachablePeriods=RangeUtil.remove(tsRange,cacheExclude);
          if (cachablePeriods.size() == 1) {
            if (!tsRange.equals(cachablePeriods.get(0))) {
              logger.info("With respect to each shard's build status, the cacheable tsRange shrinks from " + RangeUtil.formatTsRange(tsRange) + " to "+ RangeUtil.formatTsRange(cachablePeriods.get(0)));
            }
            tsRange=cachablePeriods.get(0);
          }
 else {
            return null;
          }
        }
        StreamSQLResult newCacheEntry=new StreamSQLResult(input,tsRange,partitionColRef);
        cacheManager.getCache(STORAGE_LAYER_TUPLE_CACHE).put(new Element(streamSQLDigest,newCacheEntry));
        logger.debug("cache after the query: " + newCacheEntry);
        return null;
      }
    }
);
    return tee;
  }
 else {
    return ret;
  }
}

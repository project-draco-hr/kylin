{
  super(cubeDesc,dictionaryMap);
  this.cuboidScheduler=new CuboidScheduler(cubeDesc);
  this.baseCuboidId=Cuboid.getBaseCuboidId(cubeDesc);
  this.intermediateTableDesc=new CubeJoinedFlatTableDesc(cubeDesc,null);
  this.measureCodec=new MeasureCodec(cubeDesc.getMeasures());
  Map<String,Integer> measureIndexMap=Maps.newHashMap();
  List<String> metricsAggrFuncsList=Lists.newArrayList();
  measureCount=cubeDesc.getMeasures().size();
  List<MeasureDesc> measureDescsList=Lists.newArrayList();
  hbaseMeasureRefIndex=new int[measureCount];
  int measureRef=0;
  for (  HBaseColumnFamilyDesc familyDesc : cubeDesc.getHbaseMapping().getColumnFamily()) {
    for (    HBaseColumnDesc hbaseColDesc : familyDesc.getColumns()) {
      for (      MeasureDesc measure : hbaseColDesc.getMeasures()) {
        for (int j=0; j < measureCount; j++) {
          if (cubeDesc.getMeasures().get(j).equals(measure)) {
            measureDescsList.add(measure);
            hbaseMeasureRefIndex[measureRef]=j;
            break;
          }
        }
        measureRef++;
      }
    }
  }
  for (int i=0; i < measureCount; i++) {
    MeasureDesc measureDesc=measureDescsList.get(i);
    metricsAggrFuncsList.add(measureDesc.getFunction().getExpression());
    measureIndexMap.put(measureDesc.getName(),i);
  }
  this.metricsAggrFuncs=metricsAggrFuncsList.toArray(new String[metricsAggrFuncsList.size()]);
  this.measureDescs=cubeDesc.getMeasures().toArray(new MeasureDesc[measureCount]);
}

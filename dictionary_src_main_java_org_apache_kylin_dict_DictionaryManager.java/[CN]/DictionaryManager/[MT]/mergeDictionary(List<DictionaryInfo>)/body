{
  Preconditions.checkArgument(dicts.size() >= 2,"dicts size not valid");
  DictionaryInfo firstDictInfo=null;
  int totalSize=0;
  for (  DictionaryInfo info : dicts) {
    if (firstDictInfo == null) {
      firstDictInfo=info;
    }
 else {
      if (!firstDictInfo.isDictOnSameColumn(info)) {
        throw new IllegalArgumentException("Merging dictionaries are not structurally equal(regardless of signature).");
      }
    }
    totalSize+=info.getInput().getSize();
  }
  if (firstDictInfo == null) {
    throw new IllegalArgumentException("DictionaryManager.mergeDictionary input cannot be null");
  }
  DictionaryInfo newDictInfo=new DictionaryInfo(firstDictInfo);
  TableSignature signature=newDictInfo.getInput();
  signature.setSize(totalSize);
  signature.setLastModifiedTime(System.currentTimeMillis());
  signature.setPath("merged_with_no_original_path");
  String dupDict=checkDupByInfo(newDictInfo);
  if (dupDict != null) {
    logger.info("Identical dictionary input " + newDictInfo.getInput() + ", reuse existing dictionary at "+ dupDict);
    return getDictionaryInfo(dupDict);
  }
  boolean identicalSourceDicts=true;
  for (int i=1; i < dicts.size(); ++i) {
    if (!dicts.get(0).getDictionaryObject().equals(dicts.get(i).getDictionaryObject())) {
      identicalSourceDicts=false;
      break;
    }
  }
  if (identicalSourceDicts) {
    logger.info("Use one of the merging dictionaries directly");
    return dicts.get(0);
  }
 else {
    Dictionary<?> newDict=DictionaryGenerator.mergeDictionaries(DataType.getInstance(newDictInfo.getDataType()),dicts);
    newDictInfo.setCardinality(newDict.getSize());
    return trySaveNewDict(newDict,newDictInfo);
  }
}

{
  CapabilityResult result=new CapabilityResult();
  result.capable=false;
  boolean isJoinMatch=JoinChecker.isJoinMatch(digest.joinDescs,cube);
  if (!isJoinMatch) {
    logger.info("Exclude cube " + cube.getName() + " because unmatched joins");
    return result;
  }
  Collection<TblColRef> dimensionColumns=getDimensionColumns(digest);
  Collection<FunctionDesc> aggrFunctions=digest.aggregations;
  Collection<TblColRef> unmatchedDimensions=unmatchedDimensions(dimensionColumns,cube);
  Collection<FunctionDesc> unmatchedAggregations=unmatchedAggregations(aggrFunctions,cube);
  tryCustomMeasureTypes(unmatchedDimensions,unmatchedAggregations,digest,cube,result);
  if (!unmatchedAggregations.isEmpty()) {
    tryDimensionAsMeasures(unmatchedAggregations,digest,cube,result);
  }
  if (!unmatchedDimensions.isEmpty()) {
    logger.info("Exclude cube " + cube.getName() + " because unmatched dimensions");
    return result;
  }
  if (!unmatchedAggregations.isEmpty()) {
    logger.info("Exclude cube " + cube.getName() + " because unmatched aggregations");
    return result;
  }
  if (cube.getStorageType() == IStorageAware.ID_HBASE && MassInTupleFilter.containsMassInTupleFilter(digest.filter)) {
    logger.info("Exclude cube " + cube.getName() + " because only v2 storage + v2 query engine supports massin");
    return result;
  }
  if (digest.isRawQuery() && cube.getFactTable().equals(digest.factTable)) {
    result.influences.add(new CapabilityInfluence(){
      @Override public double suggestCostMultiplier(){
        return 100;
      }
    }
);
  }
  result.capable=true;
  return result;
}

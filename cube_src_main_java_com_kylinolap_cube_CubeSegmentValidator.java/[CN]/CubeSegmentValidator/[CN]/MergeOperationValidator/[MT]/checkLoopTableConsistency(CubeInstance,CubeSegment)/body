{
  DictionaryManager dictMgr=DictionaryManager.getInstance(cube.getConfig());
  List<CubeSegment> segmentList=cube.getMergingSegments(newSegment);
  HashSet<TblColRef> cols=new HashSet<TblColRef>();
  CubeDesc cubeDesc=cube.getDescriptor();
  for (  DimensionDesc dim : cubeDesc.getDimensions()) {
    for (    TblColRef col : dim.getColumnRefs()) {
      try {
        if (newSegment.getCubeDesc().getRowkey().isUseDictionary(col)) {
          String dictTable=(String)dictMgr.decideSourceData(cubeDesc.getModel(),cubeDesc.getRowkey().getDictionary(col),col,null)[0];
          if (!cubeDesc.getFactTable().equalsIgnoreCase(dictTable)) {
            cols.add(col);
          }
        }
      }
 catch (      IOException e) {
        throw new IllegalStateException("checkLoopTableConsistency not passed when allocating a new segment.");
      }
    }
  }
  for (  TblColRef col : cols) {
    String dictOfFirstSegment=null;
    for (    CubeSegment segment : segmentList) {
      String temp=segment.getDictResPath(col);
      if (temp == null) {
        throw new IllegalStateException("Dictionary is null on column: " + col + " Segment: "+ segment);
      }
      if (dictOfFirstSegment == null) {
        dictOfFirstSegment=temp;
      }
 else {
        if (!dictOfFirstSegment.equalsIgnoreCase(temp)) {
          throw new IllegalStateException("Segments with different dictionaries(on lookup table) cannot be merged");
        }
      }
    }
  }
  CubeSegment firstSegment=null;
  for (  CubeSegment segment : segmentList) {
    if (firstSegment == null) {
      firstSegment=segment;
    }
 else {
      Collection<String> a=firstSegment.getSnapshots().values();
      Collection<String> b=segment.getSnapshots().values();
      if (!((a.size() == b.size()) && a.containsAll(b)))       throw new IllegalStateException("Segments with different snapshots cannot be merged");
    }
  }
}

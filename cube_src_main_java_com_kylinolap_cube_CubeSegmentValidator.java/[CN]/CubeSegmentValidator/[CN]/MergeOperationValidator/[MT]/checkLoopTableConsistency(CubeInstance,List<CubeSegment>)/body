{
  CubeSegment cubeSeg=newSegments.get(0);
  DictionaryManager dictMgr=DictionaryManager.getInstance(cube.getConfig());
  List<CubeSegment> segmentList=cube.getMergingSegments(cubeSeg);
  HashSet<TblColRef> cols=new HashSet<TblColRef>();
  for (  DimensionDesc dim : cube.getDescriptor().getDimensions()) {
    for (    TblColRef col : dim.getColumnRefs()) {
      try {
        if (cubeSeg.getCubeDesc().getRowkey().isUseDictionary(col) && !cube.getDescriptor().getFactTable().equalsIgnoreCase((String)dictMgr.decideSourceData(cube.getDescriptor(),col,null)[0])) {
          cols.add(col);
        }
      }
 catch (      IOException e) {
        throw new CubeIntegrityException("checkLoopTableConsistency not passed when allocating a new segment.");
      }
    }
  }
  for (  TblColRef col : cols) {
    String dictOfFirstSegment=null;
    for (    CubeSegment segment : segmentList) {
      String temp=segment.getDictResPath(col);
      if (temp == null) {
        throw new CubeIntegrityException("Dictionary is null on column: " + col + " Segment: "+ segment);
      }
      if (dictOfFirstSegment == null) {
        dictOfFirstSegment=temp;
      }
 else {
        if (!dictOfFirstSegment.equalsIgnoreCase(temp)) {
          throw new CubeIntegrityException("Segments with different dictionaries(on lookup table) cannot be merged");
        }
      }
    }
  }
  CubeSegment firstSegment=null;
  for (  CubeSegment segment : segmentList) {
    if (firstSegment == null) {
      firstSegment=segment;
    }
 else {
      Collection<String> a=firstSegment.getSnapshots().values();
      Collection<String> b=segment.getSnapshots().values();
      if ((a.size() == b.size()) && a.containsAll(b)) {
      }
 else {
        throw new CubeIntegrityException("Segments with different snapshots cannot be merged");
      }
    }
  }
}

{
  JobEngineConfig engineConfig=(JobEngineConfig)context.getJobDetail().getJobDataMap().get(JobConstants.PROP_ENGINE_CONTEXT);
  JobDAO jobDAO=JobDAO.getInstance(engineConfig.getConfig());
  try {
    log.debug("Using metadata url: " + engineConfig.getConfig().getMetadataUrl());
    log.debug("Getting pending job list");
    List<JobInstance> pendingJobList=jobDAO.listAllJobs(JobStatusEnum.PENDING);
    log.debug("Pending job count is " + pendingJobList.size());
    int leftJobs=JOB_THRESHOLD;
    Random rand=new Random();
    int maxConcurrentJobCount=engineConfig.getMaxConcurrentJobLimit();
    for (    JobInstance jobInstance : pendingJobList) {
      @SuppressWarnings("unchecked") ConcurrentHashMap<String,JobFlow> jobFlows=(ConcurrentHashMap<String,JobFlow>)context.getScheduler().getContext().get(JobConstants.PROP_JOB_RUNTIME_FLOWS);
      if (jobFlows.size() >= maxConcurrentJobCount) {
        break;
      }
      try {
        boolean cubeHasRunningJob=false;
        for (        String s : jobFlows.keySet()) {
          String[] tmp=StringSplitter.split(s,".");
          String cubename=tmp[0];
          String jobid=tmp[1];
          if (cubename.equals(jobInstance.getRelatedCube())) {
            log.info("There is already a job of cube " + jobInstance.getRelatedCube() + " running, job uuid is "+ jobid);
            cubeHasRunningJob=true;
            break;
          }
        }
        if (cubeHasRunningJob == false && jobFlows.containsKey(JobInstance.getJobIdentity(jobInstance)) == false) {
          JobFlow jobFlow=new JobFlow(jobInstance,engineConfig);
          jobFlows.put(JobInstance.getJobIdentity(jobInstance),jobFlow);
          Trigger trigger=TriggerBuilder.newTrigger().startNow().build();
          JobDetail firstStep=jobFlow.getFirst();
          context.getScheduler().scheduleJob(firstStep,trigger);
          log.info("Job " + jobInstance.getUuid() + " has been scheduled with the first step "+ firstStep.getKey().toString());
        }
      }
 catch (      Exception e) {
        log.error("Failed to trigger the job detail",e);
      }
      if (--leftJobs < 0) {
        log.info("Too many pending jobs!");
        break;
      }
      long ms=Math.abs(rand.nextLong() % 10L);
      Thread.sleep(ms * 1000L);
    }
  }
 catch (  Throwable t) {
    log.error(t.getMessage());
    throw new JobExecutionException(t);
  }
}

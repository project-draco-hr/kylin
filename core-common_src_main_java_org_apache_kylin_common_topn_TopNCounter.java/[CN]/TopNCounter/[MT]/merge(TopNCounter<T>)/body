{
  TopNCounter<T> secondCounter=new TopNCounter<T>(another.capacity);
  secondCounter.fromBytes(another.toBytes());
  double m1=0.0, m2=0.0;
  if (this.size() >= this.capacity) {
    m1=this.bucketList.tail().getValue().count;
  }
  if (secondCounter.size() >= secondCounter.capacity) {
    m2=secondCounter.bucketList.tail().getValue().count;
  }
  for (  Map.Entry<T,ListNode2<Counter<T>>> entry : this.counterMap.entrySet()) {
    T item=entry.getKey();
    ListNode2<Counter<T>> existing=secondCounter.counterMap.get(item);
    if (existing != null) {
      this.offer(item,secondCounter.counterMap.get(item).getValue().count);
      this.counterMap.get(item).getValue().error=entry.getValue().getValue().error + secondCounter.counterMap.get(item).getValue().error;
      secondCounter.counterMap.remove(item);
    }
 else {
      this.offer(item,m2);
      this.counterMap.get(item).getValue().error=entry.getValue().getValue().error + m2;
    }
  }
  for (  Map.Entry<T,ListNode2<Counter<T>>> entry : secondCounter.counterMap.entrySet()) {
    T item=entry.getKey();
    double counter=entry.getValue().getValue().count;
    double error=entry.getValue().getValue().error;
    this.offer(item,counter + m1);
    this.counterMap.get(item).getValue().error=error + m1;
  }
  return this;
}

{
  Range<Long> reusePeriod=cachedResult.getReusableResults(ts);
  logger.info("existing cache: " + cachedResult);
  logger.info("ts Range in query: " + RangeUtil.formatTsRange(ts));
  logger.info("potential reusable range: " + RangeUtil.formatTsRange(reusePeriod));
  if (reusePeriod != null) {
    List<Range<Long>> remainings=RangeUtil.remove(ts,reusePeriod);
    if (remainings.size() == 1) {
      SimpleTupleIterator reusedTuples=new SimpleTupleIterator(cachedResult.reuse(reusePeriod));
      List<ITupleIterator> iTupleIteratorList=Lists.newArrayList();
      iTupleIteratorList.add(reusedTuples);
      Range<Long> remaining=remainings.get(0);
      logger.info("Appending ts " + RangeUtil.formatTsRange(remaining) + " as additional filter");
      ITupleIterator freshTuples=SQLDigestUtil.appendTsFilterToExecute(sqlDigest,partitionColRef,remaining,new Function<Void,ITupleIterator>(){
        @Override public ITupleIterator apply(        Void input){
          return underlyingStorage.search(context,sqlDigest,returnTupleInfo);
        }
      }
);
      iTupleIteratorList.add(freshTuples);
      context.setReusedPeriod(reusePeriod);
      return new CompoundTupleIterator(iTupleIteratorList);
    }
 else     if (remainings.size() == 0) {
      logger.info("The ts range in new query was fully cached");
      context.setReusedPeriod(reusePeriod);
      return new SimpleTupleIterator(cachedResult.reuse(reusePeriod));
    }
 else {
      logger.info("Give up using cache to avoid complexity");
      return null;
    }
  }
 else {
    logger.info("cached results not reusable by current query");
    return null;
  }
}

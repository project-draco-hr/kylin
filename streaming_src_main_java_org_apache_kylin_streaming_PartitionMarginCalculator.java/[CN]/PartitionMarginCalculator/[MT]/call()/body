{
  try {
    while (true) {
      StreamMessage streamMessage=streamMessageQueue.poll(30,TimeUnit.SECONDS);
      if (streamMessage == null) {
        logger.info("The stream queue for partition {} is drained",partitionId);
        continue;
      }
      final ParsedStreamMessage parsedStreamMessage=streamParser.parse(streamMessage);
      if (parsedStreamMessage == null) {
        throw new RuntimeException("parsedStreamMessage of " + new String(streamMessage.getRawData()) + " is null");
      }
      if (parsedStreamMessage.getOffset() >= lastOffset) {
        logger.info("The final max margin for partition {} is {} ",partitionId,maxMargin);
        return new PartitionMargin(maxMargin,maxMargin);
      }
      long timestamp=parsedStreamMessage.getTimestamp();
      long wallTime=average.addNewElementAndGetAvg(timestamp);
      long formalizedTs=timestamp / 1000 * 1000;
      if (earliestOffsets.containsKey(formalizedTs)) {
        this.maxMargin=Math.max(this.maxMargin,Math.abs(earliestOffsets.get(formalizedTs) - wallTime));
      }
 else {
        earliestOffsets.put(formalizedTs,wallTime);
      }
    }
  }
 catch (  Exception e) {
    logger.error("partition margin calculation stream error, stopping",e);
    throw new RuntimeException("partition margin calculation stream error, stopping",e);
  }
 finally {
    logger.info("one partition sign off");
    countDownLatch.countDown();
  }
}

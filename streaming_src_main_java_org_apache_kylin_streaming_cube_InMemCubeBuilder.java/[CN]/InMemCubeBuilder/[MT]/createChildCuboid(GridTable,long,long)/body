{
  final ExecutorService executorService=Executors.newSingleThreadExecutor();
  final Future<GridTable> task=executorService.submit(new Callable<GridTable>(){
    @Override public GridTable call() throws Exception {
      return aggregateCuboid(parentCuboid,parentCuboidId,cuboidId);
    }
  }
);
  try {
    final GridTable gridTable=task.get(DEFAULT_TIMEOUT,TimeUnit.SECONDS);
    return gridTable;
  }
 catch (  InterruptedException e) {
    throw new RuntimeException("this should not happen",e);
  }
catch (  ExecutionException e) {
    if (e.getCause() instanceof OutOfMemoryError) {
      logger.warn("Future.get() OutOfMemory, stop the thread");
    }
 else {
      throw new RuntimeException("this should not happen",e);
    }
  }
catch (  TimeoutException e) {
    logger.warn("Future.get() timeout, stop the thread");
  }
  logger.info("shutdown executor service");
  final List<Runnable> runnables=executorService.shutdownNow();
  try {
    executorService.awaitTermination(DEFAULT_TIMEOUT,TimeUnit.SECONDS);
    waitForGc();
  }
 catch (  InterruptedException e) {
    throw new RuntimeException("this should not happen",e);
  }
  return null;
}

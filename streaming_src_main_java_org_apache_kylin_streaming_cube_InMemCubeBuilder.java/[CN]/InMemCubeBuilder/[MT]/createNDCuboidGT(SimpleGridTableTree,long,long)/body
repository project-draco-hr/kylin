{
  long startTime=System.currentTimeMillis();
  GridTable currentCuboid;
  while (true) {
    logger.info("Calculating cuboid " + cuboidId + " from parent "+ parentCuboidId);
    currentCuboid=createChildCuboid(parentNode.data,parentCuboidId,cuboidId);
    if (currentCuboid != null) {
      break;
    }
 else {
      logger.warn("create child cuboid:" + cuboidId + " from parent:"+ parentCuboidId+ " failed, prepare to gc");
      if (gc(parentNode)) {
        continue;
      }
 else {
        logger.warn("all parent node has been flushed into disk, memory is still insufficient");
        throw new RuntimeException("all parent node has been flushed into disk, memory is still insufficient");
      }
    }
  }
  SimpleGridTableTree node=new SimpleGridTableTree();
  node.parent=parentNode;
  node.data=currentCuboid;
  node.id=cuboidId;
  parentNode.children.add(node);
  logger.info("Cuboid " + cuboidId + " build takes "+ (System.currentTimeMillis() - startTime)+ "ms");
  List<Long> children=cuboidScheduler.getSpanningCuboid(cuboidId);
  if (!children.isEmpty()) {
    Collections.sort(children);
    for (    Long childId : children) {
      createNDCuboidGT(node,cuboidId,childId);
    }
  }
  outputGT(cuboidId,currentCuboid);
  dropStore(currentCuboid);
  parentNode.children.remove(node);
  if (parentNode.children.size() > 0) {
    logger.info("cuboid:" + cuboidId + " has finished, parent node:"+ parentNode.id+ " need to switch to mem store");
    ((GTComboStore)parentNode.data.getStore()).switchToMemStore();
  }
}

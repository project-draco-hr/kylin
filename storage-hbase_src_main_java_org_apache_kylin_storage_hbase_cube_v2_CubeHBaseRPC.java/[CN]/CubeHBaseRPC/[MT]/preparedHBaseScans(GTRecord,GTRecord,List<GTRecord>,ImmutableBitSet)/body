{
  final List<Pair<byte[],byte[]>> selectedColumns=makeHBaseColumns(selectedColBlocks);
  List<RawScan> ret=Lists.newArrayList();
  LazyRowKeyEncoder encoder=new LazyRowKeyEncoder(cubeSeg,cuboid);
  byte[] start=encoder.createBuf();
  byte[] end=encoder.createBuf();
  List<byte[]> startKeys;
  List<byte[]> endKeys;
  encoder.setBlankByte(RowConstants.ROWKEY_LOWER_BYTE);
  encoder.encode(pkStart,pkStart.getInfo().getPrimaryKey(),start);
  startKeys=encoder.getRowKeysDifferentShards(start);
  encoder.setBlankByte(RowConstants.ROWKEY_UPPER_BYTE);
  encoder.encode(pkEnd,pkEnd.getInfo().getPrimaryKey(),end);
  endKeys=encoder.getRowKeysDifferentShards(end);
  endKeys=Lists.transform(endKeys,new Function<byte[],byte[]>(){
    @Override public byte[] apply(    byte[] input){
      byte[] shardEnd=new byte[input.length + 1];
      System.arraycopy(input,0,shardEnd,0,input.length);
      return shardEnd;
    }
  }
);
  Preconditions.checkState(startKeys.size() == endKeys.size());
  List<Pair<byte[],byte[]>> hbaseFuzzyKeys=translateFuzzyKeys(fuzzyKeys);
  KylinConfig config=cubeSeg.getCubeDesc().getConfig();
  int hbaseCaching=config.getHBaseScanCacheRows();
  int hbaseMaxResultSize=config.getHBaseScanMaxResultSize();
  if (isMemoryHungry(selectedColBlocks))   hbaseCaching/=10;
  for (short i=0; i < startKeys.size(); ++i) {
    ret.add(new RawScan(startKeys.get(i),endKeys.get(i),selectedColumns,hbaseFuzzyKeys,hbaseCaching,hbaseMaxResultSize));
  }
  return ret;
}

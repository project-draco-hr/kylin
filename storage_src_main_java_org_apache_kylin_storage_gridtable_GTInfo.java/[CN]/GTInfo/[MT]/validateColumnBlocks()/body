{
  colAll=new BitSet();
  colAll.flip(0,colTypes.length);
  if (colBlocks == null) {
    colBlocks=new BitSet[2];
    colBlocks[0]=primaryKey;
    colBlocks[1]=(BitSet)colAll.clone();
    colBlocks[1].andNot(primaryKey);
  }
  colBlocksAll=new BitSet();
  colBlocksAll.flip(0,colBlocks.length);
  if (colPreferIndex == null)   colPreferIndex=new BitSet();
  for (int i=0; i < colBlocks.length; i++) {
    for (int j=i + 1; j < colBlocks.length; j++) {
      if (colBlocks[i].intersects(colBlocks[j]))       throw new IllegalStateException();
    }
  }
  BitSet merge=new BitSet();
  for (int i=0; i < colBlocks.length; i++) {
    merge.or(colBlocks[i]);
  }
  if (merge.equals(colAll) == false)   throw new IllegalStateException();
  if (primaryKey.equals(colBlocks[0]) == false)   throw new IllegalStateException();
  LinkedList<BitSet> tmp=new LinkedList<BitSet>(Arrays.asList(colBlocks));
  Iterator<BitSet> it=tmp.iterator();
  while (it.hasNext()) {
    BitSet cb=it.next();
    if (cb.isEmpty())     it.remove();
  }
  colBlocks=(BitSet[])tmp.toArray(new BitSet[tmp.size()]);
}

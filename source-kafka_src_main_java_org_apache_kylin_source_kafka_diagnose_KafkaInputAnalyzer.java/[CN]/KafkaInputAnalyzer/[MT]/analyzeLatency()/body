{
  long[] intervals=new long[]{1,5,60,300,1800};
  final List<BlockingQueue<StreamingMessage>> allPartitionData=consumeAll(OffsetRequest.LatestTime());
  final List<TimeHistogram> allHistograms=Lists.newArrayList();
  final TimeHistogram overallHistogram=new TimeHistogram(intervals,"overall");
  ExecutorService executorService=Executors.newFixedThreadPool(allPartitionData.size(),new DaemonThreadFactory());
  for (int i=0; i < allPartitionData.size(); ++i) {
    final int index=i;
    allHistograms.add(new TimeHistogram(intervals,"" + i));
    executorService.submit(new Runnable(){
      @Override public void run(){
        while (true) {
          try {
            StreamingMessage message=allPartitionData.get(index).take();
            long t=message.getTimestamp();
            allHistograms.get(index).processMillis(System.currentTimeMillis() - t);
            overallHistogram.processMillis(System.currentTimeMillis() - t);
          }
 catch (          InterruptedException e) {
            e.printStackTrace();
          }
        }
      }
    }
);
  }
  while (true) {
    System.out.println("Printing status at : " + new SimpleDateFormat("yyyy/MM/dd HH:mm:ss").format(Calendar.getInstance().getTime()));
    for (    TimeHistogram histogram : allHistograms) {
      histogram.printStatus();
    }
    overallHistogram.printStatus();
    Thread.sleep(300000);
  }
}

{
  super.bindCurrentConfiguration(context.getConfiguration());
  cubeName=context.getConfiguration().get(BatchConstants.CFG_CUBE_NAME).toUpperCase();
  segmentName=context.getConfiguration().get(BatchConstants.CFG_CUBE_SEGMENT_NAME).toUpperCase();
  config=AbstractHadoopJob.loadKylinPropsAndMetadata();
  cubeManager=CubeManager.getInstance(config);
  cube=cubeManager.getCube(cubeName);
  cubeDesc=cube.getDescriptor();
  mergedCubeSegment=cube.getSegment(segmentName,SegmentStatusEnum.NEW);
  newKeyBodyBuf=new byte[RowConstants.ROWKEY_BUFFER_SIZE];
  newKeyBuf=ByteArray.allocate(RowConstants.ROWKEY_BUFFER_SIZE);
  FileSplit fileSplit=(FileSplit)context.getInputSplit();
  sourceCubeSegment=findSourceSegment(fileSplit,cube);
  rowKeySplitter=new RowKeySplitter(sourceCubeSegment,65,255);
  rowKeyEncoderProvider=new RowKeyEncoderProvider(mergedCubeSegment);
  if (cubeDesc.hasMeasureUsingDictionary()) {
    measuresDescs=cubeDesc.getMeasures();
    codec=new MeasureCodec(measuresDescs);
    measureObjs=new Object[measuresDescs.size()];
    List<Integer> measuresUsingDict=Lists.newArrayList();
    for (int i=0; i < measuresDescs.size(); i++) {
      if (measuresDescs.get(i).getFunction().isTopN()) {
        measuresUsingDict.add(i);
      }
    }
    measureIdxUsingDict=measuresUsingDict.toArray(new Integer[measuresUsingDict.size()]);
    valueBuf=ByteBuffer.allocate(RowConstants.ROWVALUE_BUFFER_SIZE);
    outputValue=new Text();
  }
}

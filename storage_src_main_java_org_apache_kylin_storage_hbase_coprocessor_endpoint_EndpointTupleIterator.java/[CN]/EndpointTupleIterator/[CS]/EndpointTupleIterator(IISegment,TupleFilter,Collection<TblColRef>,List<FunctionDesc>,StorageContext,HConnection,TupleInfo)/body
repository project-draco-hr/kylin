{
  String tableName=segment.getStorageLocationIdentifier();
  table=conn.getTable(tableName);
  factTableName=segment.getIIDesc().getFactTableName();
  if (rootFilter == null) {
    rootFilter=ConstantTupleFilter.TRUE;
  }
  if (groupBy == null) {
    groupBy=Sets.newHashSet();
  }
  if (measures == null) {
    measures=Lists.newArrayList();
  }
  rewriteMeasureParameters(measures,segment.getColumns());
  this.seg=segment;
  this.columns=segment.getColumns();
  this.tupleInfo=returnTupleInfo;
  this.tupleConverter=new EndpointTupleConverter(columns,measures,returnTupleInfo);
  this.tableRecordInfo=new TableRecordInfo(this.seg);
  this.pushedDownRowType=CoprocessorRowType.fromTableRecordInfo(tableRecordInfo,this.columns);
  this.pushedDownFilter=CoprocessorFilter.fromFilter(new ClearTextDictionary(this.tableRecordInfo),rootFilter,FilterDecorator.FilterConstantsTreatment.AS_IT_IS);
  for (  TblColRef column : this.pushedDownFilter.getInevaluableColumns()) {
    groupBy.add(column);
  }
  this.pushedDownProjector=CoprocessorProjector.makeForEndpoint(tableRecordInfo,groupBy);
  this.pushedDownAggregators=EndpointAggregators.fromFunctions(tableRecordInfo,measures);
  int tsCol=this.tableRecordInfo.getTimestampColumn();
  this.partitionCol=this.columns.get(tsCol);
  this.tsRange=TsConditionExtractor.extractTsCondition(this.partitionCol,rootFilter);
  if (this.tsRange == null) {
    logger.info("TsRange conflict for endpoint, return empty directly");
    this.tupleIterator=ITupleIterator.EMPTY_TUPLE_ITERATOR;
  }
 else {
    logger.info("The tsRange being pushed is " + RangeUtil.formatTsRange(tsRange));
  }
  IIProtos.IIRequest endpointRequest=prepareRequest();
  Collection<IIProtos.IIResponse> compressedShardResults=getResults(endpointRequest,table);
  Collection<IIProtos.IIResponseInternal> shardResults=new ArrayList<>();
  for (  IIProtos.IIResponse input : compressedShardResults) {
    byte[] compressed=input.getBlob().toByteArray();
    try {
      byte[] decompressed=CompressionUtils.decompress(compressed);
      shardResults.add(IIProtos.IIResponseInternal.parseFrom(decompressed));
    }
 catch (    Exception e) {
      throw new RuntimeException("decompress endpoint response error");
    }
  }
  this.lastDataTime=Collections.min(Collections2.transform(shardResults,new Function<IIProtos.IIResponseInternal,Long>(){
    @Nullable @Override public Long apply(    IIProtos.IIResponseInternal input){
      IIProtos.IIResponseInternal.Stats status=input.getStats();
      logger.info("Endpoints all returned, stats from shard {}: start moment:{}, finish moment: {}, elapsed ms: {}, scanned slices: {}, latest slice time is {}",new Object[]{String.valueOf(status.getMyShard()),DateFormat.formatToTimeStr(status.getServiceStartTime()),DateFormat.formatToTimeStr(status.getServiceEndTime()),String.valueOf(status.getServiceEndTime() - status.getServiceStartTime()),String.valueOf(status.getScannedSlices()),DateFormat.formatToTimeStr(status.getLatestDataTime())});
      return status.getLatestDataTime();
    }
  }
));
  this.regionResponsesIterator=Collections2.transform(shardResults,new Function<IIProtos.IIResponseInternal,List<IIProtos.IIResponseInternal.IIRow>>(){
    @Nullable @Override public List<IIProtos.IIResponseInternal.IIRow> apply(    @Nullable IIProtos.IIResponseInternal input){
      return input.getRowsList();
    }
  }
).iterator();
  if (this.regionResponsesIterator.hasNext()) {
    this.tupleIterator=new SingleRegionTupleIterator(this.regionResponsesIterator.next());
  }
 else {
    this.tupleIterator=ITupleIterator.EMPTY_TUPLE_ITERATOR;
  }
}

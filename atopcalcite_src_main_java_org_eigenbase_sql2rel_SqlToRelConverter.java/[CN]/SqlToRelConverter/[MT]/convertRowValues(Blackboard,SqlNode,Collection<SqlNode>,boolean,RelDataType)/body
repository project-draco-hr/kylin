{
  final List<List<RexLiteral>> tupleList=new ArrayList<List<RexLiteral>>();
  final RelDataType rowType;
  if (targetRowType != null) {
    rowType=targetRowType;
  }
 else {
    rowType=SqlTypeUtil.promoteToRowType(typeFactory,validator.getValidatedNodeType(rowList),null);
  }
  List<RelNode> unionInputs=new ArrayList<RelNode>();
  for (  SqlNode node : rows) {
    SqlBasicCall call;
    if (isRowConstructor(node)) {
      call=(SqlBasicCall)node;
      List<RexLiteral> tuple=new ArrayList<RexLiteral>();
      for (      SqlNode operand : call.operands) {
        RexLiteral rexLiteral=convertLiteralInValuesList(operand,bb,rowType,tuple.size());
        if ((rexLiteral == null) && allowLiteralsOnly) {
          return null;
        }
        if ((rexLiteral == null) || !shouldCreateValuesRel) {
          tuple=null;
          break;
        }
        tuple.add(rexLiteral);
      }
      if (tuple != null) {
        tupleList.add(tuple);
        continue;
      }
    }
 else {
      RexLiteral rexLiteral=convertLiteralInValuesList(node,bb,rowType,0);
      if ((rexLiteral != null) && shouldCreateValuesRel) {
        tupleList.add(Collections.singletonList(rexLiteral));
        continue;
      }
 else {
        if ((rexLiteral == null) && allowLiteralsOnly) {
          return null;
        }
      }
      call=(SqlBasicCall)SqlStdOperatorTable.ROW.createCall(SqlParserPos.ZERO,node);
    }
    unionInputs.add(convertRowConstructor(bb,call));
  }
  ValuesRel valuesRel=new ValuesRel(cluster,rowType,tupleList);
  RelNode resultRel;
  if (unionInputs.isEmpty()) {
    resultRel=valuesRel;
  }
 else {
    if (!tupleList.isEmpty()) {
      unionInputs.add(valuesRel);
    }
    UnionRel unionRel=new UnionRel(cluster,unionInputs,true);
    resultRel=unionRel;
  }
  leaves.add(resultRel);
  return resultRel;
}

{
  CubeInstance cube=cubeManager.getCube("test_kylin_cube_without_slr_empty");
  final CubeDesc desc=cube.getDescriptor();
  cube.getSegments().clear();
  cubeManager.updateCube(cube);
  String tableName="kylin_intermediate_test_kylin_cube_without_slr_desc_19700101000000_20130112000000_a24dec89_efbd_425f_9a5f_8b78dd1412af";
  tableName="kylin_intermediate_test_kylin_cube_without_slr_desc_19700101000000_20130112000000_a5e1eb5d_da6b_475d_9807_be0b61f03215";
  logger.info("intermediate table name:" + tableName);
  final Configuration conf=new Configuration();
  HCatInputFormat.setInput(conf,"default",tableName);
  final HCatSchema tableSchema=HCatInputFormat.getTableSchema(conf);
  logger.info(StringUtils.join(tableSchema.getFieldNames(),"\n"));
  HiveTableReader reader=new HiveTableReader("default",tableName);
  LinkedBlockingDeque<Stream> queue=new LinkedBlockingDeque<Stream>();
  ExecutorService executorService=Executors.newSingleThreadExecutor();
  final CubeStreamBuilder streamBuilder=new CubeStreamBuilder(queue,"",cube,0);
  while (reader.next()) {
    queue.put(parse(reader.getRow()));
  }
  queue.put(new Stream(-1,null));
  final Future<?> future=executorService.submit(streamBuilder);
  try {
    future.get();
  }
 catch (  Exception e) {
    logger.error("stream build failed",e);
    fail("stream build failed");
  }
  logger.info("stream build finished, htable name:");
}

{
  final CubeManager cubeManager=CubeManager.getInstance(context.getConfig());
  final CubeInstance cube=cubeManager.getCube(getCubeName());
  final CubeSegment segment=cube.getSegmentById(getSegmentId());
  Output baseCuboidOutput=executableManager.getOutput(getBaseCuboidStepId());
  String sourceRecordsCount=baseCuboidOutput.getExtra().get(ExecutableConstants.SOURCE_RECORDS_COUNT);
  long sourceCount=0l;
  if (StringUtils.isNotEmpty(sourceRecordsCount)) {
    sourceCount=Long.parseLong(sourceRecordsCount);
  }
 else {
    logger.warn("Can not get cube source record count.");
  }
  long sourceSize=0l;
  String sourceRecordsSize=baseCuboidOutput.getExtra().get(ExecutableConstants.SOURCE_RECORDS_SIZE);
  if (StringUtils.isNotEmpty(sourceRecordsSize)) {
    sourceSize=Long.parseLong(sourceRecordsSize);
  }
 else {
    logger.warn("Can not get cube source record size.");
  }
  long size=0;
  boolean segmentReady=true;
  if (!StringUtils.isBlank(getConvertToHfileStepId())) {
    String cubeSizeString=executableManager.getOutput(getConvertToHfileStepId()).getExtra().get(ExecutableConstants.HDFS_BYTES_WRITTEN);
    if (StringUtils.isNotEmpty(cubeSizeString)) {
      size=Long.parseLong(cubeSizeString) / 1024;
    }
 else {
      logger.warn("Can't get cube segment size.");
    }
  }
 else {
    segmentReady=false;
  }
  segment.setLastBuildJobID(getCubingJobId());
  segment.setLastBuildTime(System.currentTimeMillis());
  segment.setSizeKB(size);
  segment.setInputRecords(sourceCount);
  segment.setInputRecordsSize(sourceSize);
  try {
    if (segmentReady) {
      cubeManager.promoteNewlyBuiltSegments(cube,segment);
    }
 else {
      cubeManager.updateCube(cube);
    }
    return new ExecuteResult(ExecuteResult.State.SUCCEED,"succeed");
  }
 catch (  IOException e) {
    logger.error("fail to update cube after build",e);
    return new ExecuteResult(ExecuteResult.State.ERROR,e.getLocalizedMessage());
  }
}

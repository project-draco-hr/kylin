{
  if (!initialized) {
    initialized=true;
  }
 else {
    return;
  }
  String ZKConnectString=getZKConnectString(jobEngineConfig);
  if (StringUtils.isEmpty(ZKConnectString)) {
    throw new IllegalArgumentException("ZOOKEEPER_QUORUM is empty!");
  }
  this.jobEngineConfig=jobEngineConfig;
  RetryPolicy retryPolicy=new ExponentialBackoffRetry(1000,3);
  this.zkClient=CuratorFrameworkFactory.newClient(ZKConnectString,retryPolicy);
  this.zkClient.start();
  this.sharedLock=new InterProcessMutex(zkClient,schedulerId());
  boolean hasLock=false;
  try {
    hasLock=sharedLock.acquire(3,TimeUnit.SECONDS);
  }
 catch (  Exception e) {
    logger.warn("error acquire lock",e);
  }
  if (!hasLock) {
    logger.warn("fail to acquire lock, scheduler has not been started");
    zkClient.close();
    return;
  }
  executableManager=ExecutableManager.getInstance(jobEngineConfig.getConfig());
  fetcherPool=Executors.newScheduledThreadPool(1);
  int corePoolSize=jobEngineConfig.getMaxConcurrentJobLimit();
  jobPool=new ThreadPoolExecutor(corePoolSize,corePoolSize,Long.MAX_VALUE,TimeUnit.DAYS,new SynchronousQueue<Runnable>());
  context=new DefaultContext(Maps.<String,Executable>newConcurrentMap(),jobEngineConfig.getConfig());
  for (  AbstractExecutable executable : executableManager.getAllExecutables()) {
    if (executable.getStatus() == ExecutableState.READY) {
      executableManager.updateJobOutput(executable.getId(),ExecutableState.ERROR,null,"scheduler initializing work to reset job to ERROR status");
    }
  }
  executableManager.updateAllRunningJobsToError();
  Runtime.getRuntime().addShutdownHook(new Thread(){
    public void run(){
      logger.debug("Closing zk connection");
      try {
        shutdown();
      }
 catch (      SchedulerException e) {
        logger.error("error shutdown scheduler",e);
      }
    }
  }
);
  fetcherPool.scheduleAtFixedRate(new FetcherRunner(),10,ExecutableConstants.DEFAULT_SCHEDULER_INTERVAL_SECONDS,TimeUnit.SECONDS);
  hasStarted=true;
}

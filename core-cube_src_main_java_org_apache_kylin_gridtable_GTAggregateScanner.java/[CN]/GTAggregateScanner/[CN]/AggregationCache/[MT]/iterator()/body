{
  return new Iterator<GTRecord>(){
    final Iterator<Entry<byte[],MeasureAggregator[]>> it=aggBufMap.entrySet().iterator();
    final ByteBuffer metricsBuf=ByteBuffer.allocate(info.getMaxColumnLength(metrics));
    final GTRecord secondRecord=new GTRecord(info);
    @Override public boolean hasNext(){
      return it.hasNext();
    }
    @Override public GTRecord next(){
      Entry<byte[],MeasureAggregator[]> entry=it.next();
      create(entry.getKey(),entry.getValue());
      return secondRecord;
    }
    private void create(    byte[] key,    MeasureAggregator[] value){
      int offset=0;
      for (int i=0; i < dimensions.trueBitCount(); i++) {
        int c=dimensions.trueBitAt(i);
        final int columnLength=info.codeSystem.maxCodeLength(c);
        secondRecord.set(c,new ByteArray(key,offset,columnLength));
        offset+=columnLength;
      }
      metricsBuf.clear();
      for (int i=0; i < value.length; i++) {
        int col=metrics.trueBitAt(i);
        int pos=metricsBuf.position();
        info.codeSystem.encodeColumnValue(col,value[i].getState(),metricsBuf);
        secondRecord.cols[col].set(metricsBuf.array(),pos,metricsBuf.position() - pos);
      }
    }
    @Override public void remove(){
      throw new UnsupportedOperationException();
    }
  }
;
}

{
  log.info(context.getJobDetail().getKey() + " was executed.");
  JobDataMap jobDataMap=context.getJobDetail().getJobDataMap();
  JobFlow jobFlow=(JobFlow)jobDataMap.get(JobConstants.PROP_JOB_FLOW);
  JobEngineConfig engineConfig=jobFlow.getJobengineConfig();
  String jobUuid=jobDataMap.getString(JobConstants.PROP_JOBINSTANCE_UUID);
  int stepSeqID=jobDataMap.getInt(JobConstants.PROP_JOBSTEP_SEQ_ID);
  KylinConfig config=engineConfig.getConfig();
  JobInstance jobInstance=null;
  JobStep jobStep=null;
  try {
    jobInstance=JobDAO.getInstance(config).getJob(jobUuid);
    jobStep=jobInstance.getSteps().get(stepSeqID);
    CubeInstance cube=CubeManager.getInstance(config).getCube(jobInstance.getRelatedCube());
    log.info(context.getJobDetail().getKey() + " status: " + jobStep.getStatus());
switch (jobStep.getStatus()) {
case FINISHED:
      CubeManager.getInstance(config).loadCubeCache(cube);
    updateKylinJobOnSuccess(jobInstance,stepSeqID,engineConfig);
  updateCubeSegmentInfoOnSucceed(jobInstance,engineConfig);
notifyUsers(jobInstance,engineConfig);
scheduleNextJob(context,jobInstance);
break;
case ERROR:
updateKylinJobStatus(jobInstance,stepSeqID,engineConfig);
notifyUsers(jobInstance,engineConfig);
break;
case DISCARDED:
CubeManager.getInstance(config).loadCubeCache(cube);
updateCubeSegmentInfoOnDiscard(jobInstance,engineConfig);
notifyUsers(jobInstance,engineConfig);
break;
default :
break;
}
}
 catch (Exception e) {
log.error(e.getMessage(),e);
handleException(jobUuid,stepSeqID,config,e);
}
 finally {
if (null != jobInstance && jobInstance.getStatus().isComplete()) {
try {
context.getScheduler().deleteJob(context.getJobDetail().getKey());
@SuppressWarnings("unchecked") ConcurrentHashMap<String,JobFlow> jobFlows=(ConcurrentHashMap<String,JobFlow>)context.getScheduler().getContext().get(JobConstants.PROP_JOB_RUNTIME_FLOWS);
jobFlows.remove(JobInstance.getJobIdentity(jobInstance));
}
 catch (SchedulerException e) {
log.error(e.getMessage(),e);
}
}
}
}

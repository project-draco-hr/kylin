{
  try {
    MicroStreamBatch microStreamBatch=null;
    while (true) {
      if (microStreamBatch == null) {
        microStreamBatch=new MicroStreamBatch(partitionId);
        clearCounter();
      }
      StreamMessage streamMessage=peek(streamMessageQueue,30000);
      if (streamMessage == null) {
        logger.info("The stream queue is drained, current available stream count: " + microStreamBatch.size());
        if (!microStreamBatch.isEmpty()) {
          return microStreamBatch;
        }
 else {
          continue;
        }
      }
      if (streamMessage.getOffset() < 0) {
        logger.warn("streaming encountered EOF, stop building");
        return null;
      }
      microStreamBatch.incRawMessageCount();
      final ParsedStreamMessage parsedStreamMessage=streamParser.parse(streamMessage);
      if (parsedStreamMessage == null) {
        throw new RuntimeException("parsedStreamMessage of " + new String(streamMessage.getRawData()) + " is null");
      }
      final BatchCondition.Result result=condition.apply(parsedStreamMessage);
      if (parsedStreamMessage.isAccepted()) {
        if (result == BatchCondition.Result.ACCEPT) {
          streamMessageQueue.take();
          microStreamBatch.add(parsedStreamMessage);
        }
 else         if (result == BatchCondition.Result.LAST_ACCEPT_FOR_BATCH) {
          streamMessageQueue.take();
          microStreamBatch.add(parsedStreamMessage);
          return microStreamBatch;
        }
 else         if (result == BatchCondition.Result.DISCARD) {
          streamMessageQueue.take();
        }
 else         if (result == BatchCondition.Result.REJECT) {
          return microStreamBatch;
        }
      }
 else {
        streamMessageQueue.take();
      }
    }
  }
 catch (  Exception e) {
    logger.error("build stream error, stop building",e);
    throw new RuntimeException("build stream error, stop building",e);
  }
 finally {
    logger.info("one partition sign off");
    countDownLatch.countDown();
  }
}

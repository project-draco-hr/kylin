{
  String type=jobPO.getType();
  try {
    Class<? extends AbstractExecutable> clazz=(Class<? extends AbstractExecutable>)Class.forName(type);
    Constructor<? extends AbstractExecutable> constructor=clazz.getConstructor();
    AbstractExecutable result=constructor.newInstance();
    result.setStatus(ExecutableStatus.valueOf(jobPO.getStatus()));
    result.setId(jobPO.getUuid());
    result.setExtra(jobPO.getExtra());
    List<JobPO> tasks=jobPO.getTasks();
    result.setOutput(getJobOutput(jobPO.getUuid()));
    if (tasks != null && !tasks.isEmpty()) {
      Preconditions.checkArgument(result instanceof DefaultChainedExecutable);
      for (      JobPO subTask : tasks) {
        ((DefaultChainedExecutable)result).addTask(parseTo(subTask));
      }
    }
    return result;
  }
 catch (  ReflectiveOperationException e) {
    throw new IllegalArgumentException("cannot parse this job:" + jobPO.getId(),e);
  }
}

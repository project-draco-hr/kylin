{
  this.createTestMetadata();
  this.ii=IIManager.getInstance(getTestConfig()).getII(iiName);
  this.iiDesc=ii.getDescriptor();
  List<StreamMessage> streamMessages=Lists.transform(Arrays.asList(inputData),new Function<String,StreamMessage>(){
    @Nullable @Override public StreamMessage apply(    String input){
      return new StreamMessage(System.currentTimeMillis(),input.getBytes());
    }
  }
);
  List<List<String>> parsedStreamMessages=Lists.newArrayList();
  StreamParser parser=StringStreamParser.instance;
  StreamFilter filter=DefaultStreamFilter.instance;
  long startOffset=Long.MAX_VALUE;
  long endOffset=Long.MIN_VALUE;
  long startTimestamp=Long.MAX_VALUE;
  long endTimestamp=Long.MIN_VALUE;
  for (  StreamMessage message : streamMessages) {
    ParsedStreamMessage parsedStreamMessage=parser.parse(message);
    if (filter.filter(parsedStreamMessage)) {
      if (startOffset > parsedStreamMessage.getOffset()) {
        startOffset=parsedStreamMessage.getOffset();
      }
      if (endOffset < parsedStreamMessage.getOffset()) {
        endOffset=parsedStreamMessage.getOffset();
      }
      if (startTimestamp > parsedStreamMessage.getTimestamp()) {
        startTimestamp=parsedStreamMessage.getTimestamp();
      }
      if (endTimestamp < parsedStreamMessage.getTimestamp()) {
        endTimestamp=parsedStreamMessage.getTimestamp();
      }
      parsedStreamMessages.add(parsedStreamMessage.getStreamMessage());
    }
  }
  MicroStreamBatch batch=new MicroStreamBatch(parsedStreamMessages,org.apache.kylin.common.util.Pair.newPair(startTimestamp,endTimestamp),org.apache.kylin.common.util.Pair.newPair(startOffset,endOffset));
  iiRows=Lists.newArrayList();
  final Slice slice=new SliceBuilder(iiDesc,(short)0,true).buildSlice((batch));
  IIKeyValueCodec codec=new IIKeyValueCodec(slice.getInfo());
  for (  IIRow iiRow : codec.encodeKeyValue(slice)) {
    iiRows.add(iiRow);
  }
}

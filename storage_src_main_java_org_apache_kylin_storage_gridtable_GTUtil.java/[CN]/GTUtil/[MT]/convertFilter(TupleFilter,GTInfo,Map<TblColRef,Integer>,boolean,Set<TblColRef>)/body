{
  byte[] bytes=TupleFilterSerializer.serialize(rootFilter,new TupleFilterSerializer.Decorator(){
    @Override public TupleFilter onSerialize(    TupleFilter filter){
      if (filter == null)       return null;
      if (filter.getOperator() == TupleFilter.FilterOperatorEnum.NOT && !TupleFilter.isEvaluableRecursively(filter)) {
        TupleFilter.collectColumns(filter,unevaluatableColumnCollector);
        return ConstantTupleFilter.TRUE;
      }
      if (colMapping != null && filter instanceof ColumnTupleFilter) {
        ColumnTupleFilter colFilter=(ColumnTupleFilter)filter;
        int gtColIdx=colMapping.get(colFilter.getColumn());
        return new ColumnTupleFilter(info.colRef(gtColIdx));
      }
      if (filter instanceof CompareTupleFilter) {
        if (TupleFilter.isEvaluableRecursively(filter) == false) {
          TupleFilter.collectColumns(filter,unevaluatableColumnCollector);
          return ConstantTupleFilter.TRUE;
        }
        if (encodeConstants) {
          return encodeConstants((CompareTupleFilter)filter);
        }
      }
      return filter;
    }
    @SuppressWarnings({"rawtypes","unchecked"}) private TupleFilter encodeConstants(    CompareTupleFilter oldCompareFilter){
      TblColRef externalCol=oldCompareFilter.getColumn();
      if (externalCol == null) {
        return oldCompareFilter;
      }
      Collection constValues=oldCompareFilter.getValues();
      if (constValues == null || constValues.isEmpty()) {
        return oldCompareFilter;
      }
      CompareTupleFilter newCompareFilter=new CompareTupleFilter(oldCompareFilter.getOperator());
      newCompareFilter.addChild(new ColumnTupleFilter(externalCol));
      Object firstValue=constValues.iterator().next();
      int col=colMapping == null ? externalCol.getColumn().getZeroBasedIndex() : colMapping.get(externalCol);
      TupleFilter result;
      ByteArray code;
switch (newCompareFilter.getOperator()) {
case EQ:
case IN:
        Set newValues=Sets.newHashSet();
      for (      Object value : constValues) {
        code=translate(col,value,0);
        if (!isDictNull(code))         newValues.add(code);
      }
    if (newValues.isEmpty()) {
      result=ConstantTupleFilter.FALSE;
    }
 else {
      newCompareFilter.addChild(new ConstantTupleFilter(newValues));
      result=newCompareFilter;
    }
  break;
case NEQ:
code=translate(col,firstValue,0);
if (isDictNull(code)) {
result=ConstantTupleFilter.TRUE;
}
 else {
newCompareFilter.addChild(new ConstantTupleFilter(code));
result=newCompareFilter;
}
break;
case LT:
code=translate(col,firstValue,1);
if (isDictNull(code)) {
result=ConstantTupleFilter.TRUE;
}
 else {
newCompareFilter.addChild(new ConstantTupleFilter(code));
result=newCompareFilter;
}
break;
case LTE:
code=translate(col,firstValue,-1);
if (isDictNull(code)) {
result=ConstantTupleFilter.FALSE;
}
 else {
newCompareFilter.addChild(new ConstantTupleFilter(code));
result=newCompareFilter;
}
break;
case GT:
code=translate(col,firstValue,-1);
if (isDictNull(code)) {
result=ConstantTupleFilter.TRUE;
}
 else {
newCompareFilter.addChild(new ConstantTupleFilter(code));
result=newCompareFilter;
}
break;
case GTE:
code=translate(col,firstValue,1);
if (isDictNull(code)) {
result=ConstantTupleFilter.FALSE;
}
 else {
newCompareFilter.addChild(new ConstantTupleFilter(code));
result=newCompareFilter;
}
break;
default :
throw new IllegalStateException("Cannot handle operator " + newCompareFilter.getOperator());
}
return result;
}
private boolean isDictNull(ByteArray code){
return info.codeSystem.getFilterCodeSystem().isNull(code);
}
transient ByteBuffer buf=ByteBuffer.allocate(info.maxRecordLength);
private ByteArray translate(int col,Object value,int roundingFlag){
buf.clear();
info.codeSystem.encodeColumnValue(col,value,roundingFlag,buf);
return ByteArray.copyOf(buf.array(),0,buf.position());
}
}
,info.codeSystem.getFilterCodeSystem());
return TupleFilterSerializer.deserialize(bytes,info.codeSystem.getFilterCodeSystem());
}

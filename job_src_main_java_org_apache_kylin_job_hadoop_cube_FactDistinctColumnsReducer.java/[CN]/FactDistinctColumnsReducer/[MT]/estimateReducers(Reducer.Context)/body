{
  DataModelDesc.RealizationCapacity cubeCapacity=cubeDesc.getModel().getCapacity();
  int cut;
switch (cubeCapacity) {
case SMALL:
    cut=SMALL_CUT;
  break;
case MEDIUM:
cut=MEDIUM_CUT;
break;
case LARGE:
cut=LARGE_CUT;
break;
default :
cut=SMALL_CUT;
}
System.out.println("Chosen cut for htable is " + cut);
Map<Long,Long> cuboidSizeMap=Maps.newHashMap();
long baseCuboidId=Cuboid.getBaseCuboidId(cubeDesc);
long totalSizeInM=0;
List<Long> allCuboids=new ArrayList<Long>();
allCuboids.addAll(rowKeyCountInCuboids.keySet());
Collections.sort(allCuboids);
for (long i : allCuboids) {
if (i <= baseCuboidId) {
long cuboidSize=estimateCuboidStorageSize(i,rowKeyCountInCuboids.get(i));
cuboidSizeMap.put(i,cuboidSize);
totalSizeInM+=cuboidSize;
}
}
int nRegion=Math.round((float)totalSizeInM / ((float)cut) * 1);
nRegion=Math.max(1,nRegion);
nRegion=Math.min(MAX_REGION,nRegion);
int gbPerRegion=(int)(totalSizeInM / (nRegion * 1));
gbPerRegion=Math.max(1,gbPerRegion);
System.out.println(nRegion + " regions");
System.out.println(gbPerRegion + " GB per region");
List<Long> regionSplit=Lists.newArrayList();
List<Long> allCuboidIds=Lists.newArrayList();
allCuboidIds.addAll(cuboidSizeMap.keySet());
Collections.sort(allCuboidIds);
long size=0;
int regionIndex=0;
for (long cuboidId : allCuboidIds) {
size+=cuboidSizeMap.get(cuboidId);
if (size >= gbPerRegion * 1) {
regionSplit.add(cuboidId);
System.out.println("Region " + regionIndex + " will be "+ size+ " MB, contains cuboid "+ cuboidId);
size=0;
}
}
Configuration conf=context.getConfiguration();
Path seqFilePath=new Path(statisticsOutput,"part-r-00000");
SequenceFile.Writer writer=SequenceFile.createWriter(conf,SequenceFile.Writer.file(seqFilePath),SequenceFile.Writer.keyClass(Text.class),SequenceFile.Writer.valueClass(LongWritable.class));
Text key=new Text();
try {
for (long i : regionSplit) {
key.set(Bytes.toBytes(i));
writer.append(key,new LongWritable(1l));
}
}
  finally {
writer.close();
}
}

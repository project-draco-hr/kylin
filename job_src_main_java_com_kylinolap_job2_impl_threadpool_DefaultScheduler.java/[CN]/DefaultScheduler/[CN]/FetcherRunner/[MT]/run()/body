{
  logger.info("Job Fetcher is running...");
  Map<String,Executable> runningJobs=context.getRunningJobs();
  if (runningJobs.size() >= jobEngineConfig.getMaxConcurrentJobLimit()) {
    logger.warn("There are too many jobs running, Job Fetch will wait until next schedule time");
    return;
  }
  for (  final AbstractExecutable executable : executableManager.getAllExecutables()) {
    final String id=executable.getId();
    String jobDesc=executable.toString();
    if (runningJobs.containsKey(id)) {
      logger.info(jobDesc + " is already running");
      continue;
    }
    if (!executable.isRunnable()) {
      logger.info(jobDesc + " not runnable");
      continue;
    }
    logger.info(jobDesc + " prepare to schedule");
    try {
      context.addRunningJob(executable);
      jobPool.execute(new JobRunner(executable));
      logger.info(jobDesc + " scheduled");
    }
 catch (    Exception ex) {
      context.removeRunningJob(executable);
      logger.warn(jobDesc + " fail to schedule",ex);
    }
  }
  logger.info("Job Fetcher finish running");
}

{
  final CubeDesc cubeDesc=cubeSegment.getCubeDesc();
  final List<Integer> rowkeyColumnSize=Lists.newArrayList();
  final long baseCuboidId=Cuboid.getBaseCuboidId(cubeDesc);
  Cuboid baseCuboid=Cuboid.findById(cubeDesc,baseCuboidId);
  List<TblColRef> columnList=baseCuboid.getColumns();
  for (int i=0; i < columnList.size(); i++) {
    logger.info("Rowkey column " + i + " length "+ cubeSegment.getColumnLength(columnList.get(i)));
    rowkeyColumnSize.add(cubeSegment.getColumnLength(columnList.get(i)));
  }
  DataModelDesc.RealizationCapacity cubeCapacity=cubeDesc.getModel().getCapacity();
  int cut=kylinConfig.getHBaseRegionCut(cubeCapacity.toString());
  logger.info("Cube capacity " + cubeCapacity.toString() + ", chosen cut for HTable is "+ cut+ "GB");
  long totalSizeInM=0;
  List<Long> allCuboids=Lists.newArrayList();
  allCuboids.addAll(cubeRowCountMap.keySet());
  Collections.sort(allCuboids);
  Map<Long,Long> cubeSizeMap=Maps.transformEntries(cubeRowCountMap,new Maps.EntryTransformer<Long,Long,Long>(){
    @Override public Long transformEntry(    @Nullable Long key,    @Nullable Long value){
      return estimateCuboidStorageSize(cubeDesc,key,value,baseCuboidId,rowkeyColumnSize);
    }
  }
);
  for (  Long cuboidSize : cubeSizeMap.values()) {
    totalSizeInM+=cuboidSize;
  }
  int nRegion=Math.round((float)totalSizeInM / (cut * 1024L));
  nRegion=Math.max(kylinConfig.getHBaseRegionCutMin(),nRegion);
  nRegion=Math.min(kylinConfig.getHBaseRegionCutMax(),nRegion);
  int mbPerRegion=(int)(totalSizeInM / (nRegion));
  mbPerRegion=Math.max(1,mbPerRegion);
  logger.info("Total size " + totalSizeInM + "M (estimated)");
  logger.info(nRegion + " regions (estimated)");
  logger.info(mbPerRegion + " MB per region (estimated)");
  List<Long> regionSplit=Lists.newArrayList();
  long size=0;
  int regionIndex=0;
  int cuboidCount=0;
  for (int i=0; i < allCuboids.size(); i++) {
    long cuboidId=allCuboids.get(i);
    if (size >= mbPerRegion || (size + cubeSizeMap.get(cuboidId)) >= mbPerRegion * 1.2) {
      regionSplit.add(cuboidId);
      logger.info("Region " + regionIndex + " will be "+ size+ " MB, contains cuboids < "+ cuboidId+ " ("+ cuboidCount+ ") cuboids");
      size=0;
      cuboidCount=0;
      regionIndex++;
    }
    size+=cubeSizeMap.get(cuboidId);
    cuboidCount++;
  }
  byte[][] result=new byte[regionSplit.size()][];
  for (int i=0; i < regionSplit.size(); i++) {
    result[i]=Bytes.toBytes(regionSplit.get(i));
  }
  return result;
}

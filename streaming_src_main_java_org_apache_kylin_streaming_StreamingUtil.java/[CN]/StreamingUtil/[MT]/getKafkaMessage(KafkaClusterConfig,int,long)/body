{
  final String topic=kafkaClusterConfig.getTopic();
  int retry=0;
  while (retry < MAX_RETRY_TIMES) {
    final Broker leadBroker=getLeadBroker(kafkaClusterConfig,partitionId);
    if (leadBroker == null) {
      logger.warn("unable to find leadBroker with config:" + kafkaClusterConfig + " partitionId:"+ partitionId);
      sleep(retry++);
      continue;
    }
    final FetchResponse response=KafkaRequester.fetchResponse(topic,partitionId,offset,leadBroker,kafkaClusterConfig);
    if (response.errorCode(topic,partitionId) != 0) {
      logger.warn("errorCode of FetchResponse is:" + response.errorCode(topic,partitionId));
      sleep(retry++);
      continue;
    }
    final Iterator<MessageAndOffset> iterator=response.messageSet(topic,partitionId).iterator();
    if (!iterator.hasNext()) {
      logger.warn("messageSet is empty");
      sleep(retry++);
      continue;
    }
    return iterator.next();
  }
  try {
    Pair<Long,Long> newStartEnd=getFirstAndLastOffset(kafkaClusterConfig,partitionId);
    logger.info("Partition: {}, latest start offset: {} ,latest end offset: {}",new Object[]{partitionId,newStartEnd.getFirst(),newStartEnd.getSecond()});
  }
 catch (  Exception e) {
    logger.warn("something went wrong",e);
  }
  throw new IllegalStateException(String.format("try to get timestamp of topic: %s, partitionId: %d, offset: %d, failed to get StreamMessage from kafka",topic,partitionId,offset));
}

{
  Scan scan=new Scan();
  scan.addColumn(IIDesc.HBASE_FAMILY_BYTES,IIDesc.HBASE_QUALIFIER_BYTES);
  scan.addColumn(IIDesc.HBASE_FAMILY_BYTES,IIDesc.HBASE_DICTIONARY_BYTES);
  if (request.hasTsRange()) {
    Range<Long> tsRange=(Range<Long>)SerializationUtils.deserialize(request.getTsRange().toByteArray());
    byte[] regionStartKey=region.getStartKey();
    if (!ArrayUtils.isEmpty(regionStartKey)) {
      shard=BytesUtil.readUnsigned(regionStartKey,0,IIKeyValueCodec.SHARD_LEN);
    }
 else {
      shard=0;
    }
    logger.info("Start key of the region is: " + BytesUtil.toReadableText(regionStartKey) + ", making shard to be :"+ shard);
    if (tsRange.hasLowerBound()) {
      Preconditions.checkArgument(shard != -1,"Shard is -1!");
      long tsStart=tsRange.lowerEndpoint();
      logger.info("ts start is " + tsStart);
      byte[] idealStartKey=new byte[IIKeyValueCodec.SHARD_LEN + IIKeyValueCodec.TIMEPART_LEN];
      BytesUtil.writeUnsigned(shard,idealStartKey,0,IIKeyValueCodec.SHARD_LEN);
      BytesUtil.writeLong(tsStart,idealStartKey,IIKeyValueCodec.SHARD_LEN,IIKeyValueCodec.TIMEPART_LEN);
      logger.info("ideaStartKey is(readable) :" + BytesUtil.toReadableText(idealStartKey));
      Result result=region.getClosestRowBefore(idealStartKey,IIDesc.HBASE_FAMILY_BYTES);
      if (result != null) {
        byte[] actualStartKey=Arrays.copyOf(result.getRow(),IIKeyValueCodec.SHARD_LEN + IIKeyValueCodec.TIMEPART_LEN);
        scan.setStartRow(actualStartKey);
        logger.info("The start key is set to " + BytesUtil.toReadableText(actualStartKey));
      }
 else {
        logger.info("There is no key before ideaStartKey so ignore tsStart");
      }
    }
    if (tsRange.hasUpperBound()) {
      Preconditions.checkArgument(shard != -1,"Shard is -1");
      long tsEnd=tsRange.upperEndpoint();
      logger.info("ts end is " + tsEnd);
      byte[] actualEndKey=new byte[IIKeyValueCodec.SHARD_LEN + IIKeyValueCodec.TIMEPART_LEN];
      BytesUtil.writeUnsigned(shard,actualEndKey,0,IIKeyValueCodec.SHARD_LEN);
      BytesUtil.writeLong(tsEnd + 1,actualEndKey,IIKeyValueCodec.SHARD_LEN,IIKeyValueCodec.TIMEPART_LEN);
      scan.setStopRow(actualEndKey);
      logger.info("The stop key is set to " + BytesUtil.toReadableText(actualEndKey));
    }
  }
  return scan;
}

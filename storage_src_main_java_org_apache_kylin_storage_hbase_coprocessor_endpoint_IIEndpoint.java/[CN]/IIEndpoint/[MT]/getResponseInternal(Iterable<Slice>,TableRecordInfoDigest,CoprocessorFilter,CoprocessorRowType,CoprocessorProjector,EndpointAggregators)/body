{
  boolean needAgg=projector.hasGroupby() || !aggregators.isEmpty();
  EndpointAggregationCache aggCache=new EndpointAggregationCache(aggregators);
  final int byteFormLen=recordInfo.getByteFormLen();
  int totalByteFormLen=0;
  IIProtos.IIResponseInternal.Builder responseBuilder=IIProtos.IIResponseInternal.newBuilder();
  ClearTextDictionary clearTextDictionary=new ClearTextDictionary(recordInfo,type);
  RowKeyColumnIO rowKeyColumnIO=new RowKeyColumnIO(clearTextDictionary);
  byte[] recordBuffer=new byte[recordInfo.getByteFormLen()];
  final byte[] buffer=new byte[CoprocessorConstants.METRIC_SERIALIZE_BUFFER_SIZE];
  int iteratedSliceCount=0;
  long latestSliceTs=Long.MIN_VALUE;
  for (  Slice slice : slices) {
    latestSliceTs=slice.getTimestamp();
    iteratedSliceCount++;
    final Dictionary<?>[] localDictionaries=slice.getLocalDictionaries();
    CoprocessorFilter newFilter;
    final boolean emptyDictionary=Array.isEmpty(localDictionaries);
    logger.info("empty dictionary:" + emptyDictionary);
    if (emptyDictionary) {
      newFilter=filter;
    }
 else {
      for (      Dictionary<?> localDictionary : localDictionaries) {
        if (localDictionary instanceof TrieDictionary) {
          ((TrieDictionary)localDictionary).enableIdToValueBytesCache();
        }
      }
      newFilter=CoprocessorFilter.fromFilter(new LocalDictionary(localDictionaries,type,slice.getInfo()),filter.getFilter(),FilterDecorator.FilterConstantsTreatment.REPLACE_WITH_LOCAL_DICT);
    }
    ConciseSet result=null;
    if (filter != null) {
      result=new BitMapFilterEvaluator(new SliceBitMapProvider(slice,type)).evaluate(newFilter.getFilter());
    }
    Iterator<RawTableRecord> iterator=slice.iterateWithBitmap(result);
    while (iterator.hasNext()) {
      final RawTableRecord rawTableRecord=iterator.next();
      decodeWithDictionary(recordBuffer,rawTableRecord,localDictionaries,recordInfo,rowKeyColumnIO,type);
      if (needAgg) {
        AggrKey aggKey=projector.getAggrKey(recordBuffer);
        MeasureAggregator[] bufs=aggCache.getBuffer(aggKey);
        aggregators.aggregate(bufs,recordBuffer);
        aggCache.checkMemoryUsage();
      }
 else {
        if (totalByteFormLen >= MEMORY_LIMIT) {
          throw new RuntimeException("the query has exceeded the memory limit, please check the query");
        }
        IIProtos.IIResponseInternal.IIRow.Builder rowBuilder=IIProtos.IIResponseInternal.IIRow.newBuilder().setColumns(ByteString.copyFrom(recordBuffer));
        responseBuilder.addRows(rowBuilder.build());
        totalByteFormLen+=byteFormLen;
      }
    }
  }
  logger.info("Iterated Slices count: " + iteratedSliceCount);
  if (needAgg) {
    for (    Map.Entry<AggrKey,MeasureAggregator[]> entry : aggCache.getAllEntries()) {
      AggrKey aggrKey=entry.getKey();
      IIProtos.IIResponseInternal.IIRow.Builder rowBuilder=IIProtos.IIResponseInternal.IIRow.newBuilder().setColumns(ByteString.copyFrom(aggrKey.get(),aggrKey.offset(),aggrKey.length()));
      int length=aggregators.serializeMetricValues(entry.getValue(),buffer);
      rowBuilder.setMeasures(ByteString.copyFrom(buffer,0,length));
      responseBuilder.addRows(rowBuilder.build());
    }
  }
  responseBuilder.setStats(IIProtos.IIResponseInternal.Stats.newBuilder().setLatestDataTime(latestSliceTs).setServiceStartTime(this.serviceStartTime).setServiceEndTime(System.currentTimeMillis()).setScannedSlices(iteratedSliceCount));
  return responseBuilder.build();
}

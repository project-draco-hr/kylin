{
  IIProtos.IIResponseInternal.Builder responseBuilder=IIProtos.IIResponseInternal.newBuilder();
  ClearTextDictionary clearTextDictionary=new ClearTextDictionary(recordInfo,type);
  RowKeyColumnIO rowKeyColumnIO=new RowKeyColumnIO(clearTextDictionary);
  final int byteFormLen=recordInfo.getByteFormLen();
  int totalSize=0;
  byte[] recordBuffer=new byte[byteFormLen];
  int iteratedSliceCount=0;
  long latestSliceTs=Long.MIN_VALUE;
  for (  Slice slice : slices) {
    latestSliceTs=slice.getTimestamp();
    iteratedSliceCount++;
    CoprocessorFilter newFilter=CoprocessorFilter.fromFilter(new LocalDictionary(slice.getLocalDictionaries(),type,slice.getInfo()),filter.getFilter(),FilterDecorator.FilterConstantsTreatment.REPLACE_WITH_LOCAL_DICT);
    ConciseSet result=null;
    if (filter != null) {
      result=new BitMapFilterEvaluator(new SliceBitMapProvider(slice,type)).evaluate(newFilter.getFilter());
    }
    Iterator<RawTableRecord> iterator=slice.iterateWithBitmap(result);
    while (iterator.hasNext()) {
      if (totalSize >= MEMORY_LIMIT) {
        throw new RuntimeException("the query has exceeded the memory limit, please check the query");
      }
      final RawTableRecord rawTableRecord=iterator.next();
      decodeWithDictionary(recordBuffer,rawTableRecord,slice.getLocalDictionaries(),recordInfo,rowKeyColumnIO,type);
      IIProtos.IIResponseInternal.IIRow.Builder rowBuilder=IIProtos.IIResponseInternal.IIRow.newBuilder().setColumns(ByteString.copyFrom(recordBuffer));
      responseBuilder.addRows(rowBuilder.build());
      totalSize+=byteFormLen;
    }
  }
  logger.info("Iterated Slices count: " + iteratedSliceCount);
  responseBuilder.setStats(IIProtos.IIResponseInternal.Stats.newBuilder().setLatestDataTime(latestSliceTs).setServiceStartTime(this.serviceStartTime).setServiceEndTime(System.currentTimeMillis()).setScannedSlices(iteratedSliceCount));
  return responseBuilder.build();
}

{
  IIProtos.IIResponse.Builder responseBuilder=IIProtos.IIResponse.newBuilder();
  final byte[] buffer=new byte[CoprocessorConstants.METRIC_SERIALIZE_BUFFER_SIZE];
  ClearTextDictionary clearTextDictionary=new ClearTextDictionary(recordInfo,type);
  RowKeyColumnIO rowKeyColumnIO=new RowKeyColumnIO(clearTextDictionary);
  final int byteFormLen=recordInfo.getByteFormLen();
  int totalSize=0;
  byte[] recordBuffer=new byte[byteFormLen];
  for (  Slice slice : slices) {
    CoprocessorFilter newFilter=CoprocessorFilter.fromFilter(new LocalDictionary(slice.getLocalDictionaries(),type,slice.getInfo()),filter.getFilter(),FilterDecorator.FilterConstantsTreatment.REPLACE_WITH_LOCAL_DICT);
    ConciseSet result=null;
    if (filter != null) {
      result=new BitMapFilterEvaluator(new SliceBitMapProvider(slice,type)).evaluate(newFilter.getFilter());
    }
    Iterator<RawTableRecord> iterator=slice.iterateWithBitmap(result);
    while (iterator.hasNext()) {
      if (totalSize >= MEMORY_LIMIT) {
        throw new RuntimeException("the query has exceeded the memory limit, please check the query");
      }
      final RawTableRecord rawTableRecord=iterator.next();
      decodeWithDictionary(recordBuffer,rawTableRecord,slice.getLocalDictionaries(),recordInfo,buffer,rowKeyColumnIO,type);
      IIProtos.IIResponse.IIRow.Builder rowBuilder=IIProtos.IIResponse.IIRow.newBuilder().setColumns(ByteString.copyFrom(recordBuffer));
      responseBuilder.addRows(rowBuilder.build());
      totalSize+=byteFormLen;
    }
  }
  return responseBuilder.build();
}

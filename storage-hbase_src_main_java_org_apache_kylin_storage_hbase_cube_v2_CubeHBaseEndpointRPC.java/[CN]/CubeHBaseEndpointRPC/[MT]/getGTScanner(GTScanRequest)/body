{
  final ImmutableBitSet selectedColBlocks=scanRequest.getSelectedColBlocks().set(0);
  HConnection hbaseConn=HBaseConnection.get(cubeSeg.getCubeInstance().getConfig().getStorageUrl());
  final HTableInterface hbaseTable=hbaseConn.getTable(cubeSeg.getStorageLocationIdentifier());
  List<RawScan> rawScans=preparedHBaseScan(scanRequest.getPkStart(),scanRequest.getPkEnd(),scanRequest.getFuzzyKeys(),selectedColBlocks);
  List<List<Integer>> hbaseColumnsToGT=getHBaseColumnsGTMapping(selectedColBlocks);
  final List<IntList> hbaseColumnsToGTIntList=Lists.newArrayList();
  for (  List<Integer> list : hbaseColumnsToGT) {
    hbaseColumnsToGTIntList.add(IntList.newBuilder().addAllInts(list).build());
  }
  byte[] scanRequestBytes=KryoUtils.serialize(scanRequest);
  final ByteString scanRequestBytesString=HBaseZeroCopyByteString.wrap(scanRequestBytes);
  logger.info("Serialized scanRequestBytes's size is " + scanRequestBytes.length);
  ExecutorService executorService=Executors.newFixedThreadPool(rawScans.size());
  final List<byte[]> rowBlocks=Collections.synchronizedList(Lists.<byte[]>newArrayList());
  logger.info("Total RawScan range count: " + rawScans.size());
  for (  RawScan rawScan : rawScans) {
    logScan(rawScan,cubeSeg.getStorageLocationIdentifier());
  }
  final AtomicInteger totalScannedCount=new AtomicInteger(0);
  for (int i=0; i < rawScans.size(); ++i) {
    final int shardIndex=i;
    final RawScan rawScan=rawScans.get(i);
    executorService.submit(new Runnable(){
      @Override public void run(){
        final byte[] rawScanBytes=KryoUtils.serialize(rawScan);
        CubeVisitProtos.CubeVisitRequest.Builder builder=CubeVisitProtos.CubeVisitRequest.newBuilder();
        builder.setGtScanRequest(scanRequestBytesString).setHbaseRawScan(HBaseZeroCopyByteString.wrap(rawScanBytes));
        for (        IntList intList : hbaseColumnsToGTIntList) {
          builder.addHbaseColumnsToGT(intList);
        }
        String toggle=BackdoorToggles.getCoprocessorBehavior();
        if (toggle == null) {
          toggle=CoprocessorBehavior.SCAN_FILTER_AGGR_CHECKMEM.toString();
        }
 else {
          logger.info("The execution of this query will use " + toggle + " as endpoint's behavior");
        }
        builder.setBehavior(toggle);
        Collection<CubeVisitProtos.CubeVisitResponse> results;
        try {
          results=getResults(builder.build(),hbaseTable,rawScan.startKey,rawScan.endKey);
        }
 catch (        Throwable throwable) {
          throw new RuntimeException("Error when visiting cubes by endpoint:",throwable);
        }
        if (results.size() != 1) {
          logger.warn("{} CubeVisitResponse returned for shard {}",results.size(),shardIndex);
        }
        for (        CubeVisitProtos.CubeVisitResponse result : results) {
          totalScannedCount.addAndGet(result.getStats().getScannedRowCount());
          logger.info(getStatsString(result,shardIndex));
        }
        Collection<byte[]> part=Collections2.transform(results,new Function<CubeVisitProtos.CubeVisitResponse,byte[]>(){
          @Nullable @Override public byte[] apply(          CubeVisitProtos.CubeVisitResponse input){
            try {
              return CompressionUtils.decompress(HBaseZeroCopyByteString.zeroCopyGetBytes(input.getCompressedRows()));
            }
 catch (            IOException|DataFormatException e) {
              throw new RuntimeException(e);
            }
          }
        }
);
        rowBlocks.addAll(part);
      }
    }
);
  }
  executorService.shutdown();
  try {
    if (!executorService.awaitTermination(1,TimeUnit.HOURS)) {
      throw new RuntimeException("Visiting cube by endpoint timeout");
    }
  }
 catch (  InterruptedException e) {
    throw new RuntimeException("Visiting cube by endpoint gets interrupted");
  }
  return new EndpointResultsAsGTScanner(fullGTInfo,rowBlocks.iterator(),scanRequest.getColumns(),totalScannedCount.get());
}

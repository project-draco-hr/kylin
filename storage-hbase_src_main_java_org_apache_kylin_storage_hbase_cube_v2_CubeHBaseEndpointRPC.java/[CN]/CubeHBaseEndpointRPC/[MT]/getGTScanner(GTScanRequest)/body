{
  final ImmutableBitSet selectedColBlocks=scanRequest.getSelectedColBlocks().set(0);
  HConnection hbaseConn=HBaseConnection.get(cubeSeg.getCubeInstance().getConfig().getStorageUrl());
  final HTableInterface hbaseTable=hbaseConn.getTable(cubeSeg.getStorageLocationIdentifier());
  List<RawScan> rawScans=preparedHBaseScan(scanRequest.getPkStart(),scanRequest.getPkEnd(),scanRequest.getFuzzyKeys(),selectedColBlocks);
  List<List<Integer>> hbaseColumnsToGT=getHBaseColumnsGTMapping(selectedColBlocks);
  final List<IntList> hbaseColumnsToGTIntList=Lists.newArrayList();
  for (  List<Integer> list : hbaseColumnsToGT) {
    hbaseColumnsToGTIntList.add(IntList.newBuilder().addAllInts(list).build());
  }
  ByteBuffer buffer=ByteBuffer.allocate(BytesSerializer.SERIALIZE_BUFFER_SIZE);
  GTScanRequest.serializer.serialize(scanRequest,buffer);
  buffer.flip();
  final ByteString scanRequestBytesString=HBaseZeroCopyByteString.wrap(buffer.array(),buffer.position(),buffer.limit());
  logger.debug("Serialized scanRequestBytes's size is " + (buffer.limit() - buffer.position()));
  final List<byte[]> rowBlocks=Collections.synchronizedList(Lists.<byte[]>newArrayList());
  logger.debug("Total RawScan range count: " + rawScans.size());
  for (  RawScan rawScan : rawScans) {
    logScan(rawScan,cubeSeg.getStorageLocationIdentifier());
  }
  final AtomicInteger totalScannedCount=new AtomicInteger(0);
  final String toggle=BackdoorToggles.getCoprocessorBehavior() == null ? CoprocessorBehavior.SCAN_FILTER_AGGR_CHECKMEM.toString() : BackdoorToggles.getCoprocessorBehavior();
  logger.debug("The execution of this query will use " + toggle + " as endpoint's behavior");
  List<Future<?>> futures=Lists.newArrayList();
  for (int i=0; i < rawScans.size(); ++i) {
    final int shardIndex=i;
    final RawScan rawScan=rawScans.get(i);
    Future<?> future=executorService.submit(new Runnable(){
      @Override public void run(){
        ByteBuffer rawScanBuffer=ByteBuffer.allocate(BytesSerializer.SERIALIZE_BUFFER_SIZE);
        RawScan.serializer.serialize(rawScan,rawScanBuffer);
        rawScanBuffer.flip();
        CubeVisitProtos.CubeVisitRequest.Builder builder=CubeVisitProtos.CubeVisitRequest.newBuilder();
        builder.setGtScanRequest(scanRequestBytesString).setHbaseRawScan(HBaseZeroCopyByteString.wrap(rawScanBuffer.array(),rawScanBuffer.position(),rawScanBuffer.limit()));
        for (        IntList intList : hbaseColumnsToGTIntList) {
          builder.addHbaseColumnsToGT(intList);
        }
        builder.setRowkeyPreambleSize(cubeSeg.getRowKeyPreambleSize());
        builder.setBehavior(toggle);
        Collection<CubeVisitProtos.CubeVisitResponse> results;
        try {
          results=getResults(builder.build(),hbaseTable,rawScan.startKey,rawScan.endKey);
        }
 catch (        Throwable throwable) {
          throw new RuntimeException("Error when visiting cubes by endpoint:",throwable);
        }
        if (results.size() != 1) {
          logger.info("{} CubeVisitResponse returned for shard {}",results.size(),shardIndex);
        }
        for (        CubeVisitProtos.CubeVisitResponse result : results) {
          totalScannedCount.addAndGet(result.getStats().getScannedRowCount());
          logger.info(getStatsString(result,shardIndex));
        }
        Collection<byte[]> part=Collections2.transform(results,new Function<CubeVisitProtos.CubeVisitResponse,byte[]>(){
          @Nullable @Override public byte[] apply(          CubeVisitProtos.CubeVisitResponse input){
            try {
              return CompressionUtils.decompress(HBaseZeroCopyByteString.zeroCopyGetBytes(input.getCompressedRows()));
            }
 catch (            IOException|DataFormatException e) {
              throw new RuntimeException(e);
            }
          }
        }
);
        rowBlocks.addAll(part);
      }
    }
);
    futures.add(future);
  }
  try {
    for (    Future<?> future : futures) {
      future.get(1,TimeUnit.HOURS);
    }
  }
 catch (  InterruptedException e) {
    throw new RuntimeException("Visiting cube by endpoint gets interrupted",e);
  }
catch (  ExecutionException e) {
    throw new RuntimeException("Visiting cube throw exception",e);
  }
catch (  TimeoutException e) {
    throw new RuntimeException("Visiting cube by endpoint timeout",e);
  }
  return new EndpointResultsAsGTScanner(fullGTInfo,rowBlocks.iterator(),scanRequest.getColumns(),totalScannedCount.get());
}

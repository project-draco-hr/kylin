{
  final String toggle=BackdoorToggles.getCoprocessorBehavior() == null ? CoprocessorBehavior.SCAN_FILTER_AGGR_CHECKMEM.toString() : BackdoorToggles.getCoprocessorBehavior();
  logger.debug("New scanner for current segment {} will use {} as endpoint's behavior",cubeSeg,toggle);
  short cuboidBaseShard=cubeSeg.getCuboidBaseShard(this.cuboid.getId());
  short shardNum=cubeSeg.getCuboidShardNum(this.cuboid.getId());
  int totalShards=cubeSeg.getTotalShards();
  final List<ByteString> scanRequestByteStrings=Lists.newArrayList();
  final List<ByteString> rawScanByteStrings=Lists.newArrayList();
  final ImmutableBitSet selectedColBlocks=scanRequests.get(0).getSelectedColBlocks().set(0);
  final HConnection conn=HBaseConnection.get(cubeSeg.getCubeInstance().getConfig().getStorageUrl());
  final List<IntList> hbaseColumnsToGTIntList=Lists.newArrayList();
  List<List<Integer>> hbaseColumnsToGT=getHBaseColumnsGTMapping(selectedColBlocks);
  for (  List<Integer> list : hbaseColumnsToGT) {
    hbaseColumnsToGTIntList.add(IntList.newBuilder().addAllInts(list).build());
  }
  boolean scanLogged=false;
  for (  GTScanRequest req : scanRequests) {
    ByteBuffer buffer=ByteBuffer.allocate(BytesSerializer.SERIALIZE_BUFFER_SIZE);
    GTScanRequest.serializer.serialize(req,buffer);
    buffer.flip();
    scanRequestByteStrings.add(HBaseZeroCopyByteString.wrap(buffer.array(),buffer.position(),buffer.limit()));
    RawScan rawScan=preparedHBaseScan(req.getPkStart(),req.getPkEnd(),req.getFuzzyKeys(),selectedColBlocks);
    ByteBuffer rawScanBuffer=ByteBuffer.allocate(BytesSerializer.SERIALIZE_BUFFER_SIZE);
    RawScan.serializer.serialize(rawScan,rawScanBuffer);
    rawScanBuffer.flip();
    rawScanByteStrings.add(HBaseZeroCopyByteString.wrap(rawScanBuffer.array(),rawScanBuffer.position(),rawScanBuffer.limit()));
    logger.debug("Serialized scanRequestBytes {} bytes, rawScanBytesString {} bytes",buffer.limit() - buffer.position(),rawScanBuffer.limit() - rawScanBuffer.position());
    if (!scanLogged) {
      logger.info("The scan(s) info for current segment is as below, shard part of start/end key is set to 0",cubeSeg);
      logScan(rawScan,cubeSeg.getStorageLocationIdentifier());
      scanLogged=true;
    }
  }
  logger.debug("Submitting rpc to {} shards starting from shard {}, scan requests count {}",new Object[]{shardNum,cuboidBaseShard,scanRequests.size()});
  final AtomicInteger totalScannedCount=new AtomicInteger(0);
  final ExpectedSizeIterator epResultItr=new ExpectedSizeIterator(scanRequests.size() * shardNum);
  for (  final Pair<byte[],byte[]> epRange : getEPKeyRanges(cuboidBaseShard,shardNum,totalShards)) {
    for (int i=0; i < scanRequests.size(); ++i) {
      final int scanIndex=i;
      executorService.submit(new Runnable(){
        @Override public void run(){
          CubeVisitProtos.CubeVisitRequest.Builder builder=CubeVisitProtos.CubeVisitRequest.newBuilder();
          builder.setGtScanRequest(scanRequestByteStrings.get(scanIndex)).setHbaseRawScan(rawScanByteStrings.get(scanIndex));
          for (          IntList intList : hbaseColumnsToGTIntList) {
            builder.addHbaseColumnsToGT(intList);
          }
          builder.setRowkeyPreambleSize(cubeSeg.getRowKeyPreambleSize());
          builder.setBehavior(toggle);
          Map<byte[],CubeVisitProtos.CubeVisitResponse> results;
          try {
            results=getResults(builder.build(),conn.getTable(cubeSeg.getStorageLocationIdentifier()),epRange.getFirst(),epRange.getSecond());
          }
 catch (          Throwable throwable) {
            throw new RuntimeException("Error when visiting cubes by endpoint:",throwable);
          }
          for (          Map.Entry<byte[],CubeVisitProtos.CubeVisitResponse> result : results.entrySet()) {
            totalScannedCount.addAndGet(result.getValue().getStats().getScannedRowCount());
            logger.info(getStatsString(result));
            try {
              epResultItr.append(CompressionUtils.decompress(HBaseZeroCopyByteString.zeroCopyGetBytes(result.getValue().getCompressedRows())));
            }
 catch (            IOException|DataFormatException e) {
              throw new RuntimeException("Error when decompressing",e);
            }
          }
        }
      }
);
    }
  }
  return new EndpointResultsAsGTScanner(fullGTInfo,epResultItr,scanRequests.get(0).getColumns(),totalScannedCount.get());
}

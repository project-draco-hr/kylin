{
  try {
    MicroStreamBatch microStreamBatch=null;
    while (true) {
      if (microStreamBatch == null) {
        microStreamBatch=new MicroStreamBatch();
        clearCounter();
      }
      StreamMessage streamMessage=peek(streamMessageQueue,30000);
      if (streamMessage == null) {
        logger.info("The stream queue is drained, current available stream count: " + microStreamBatch.size());
        if (!microStreamBatch.isEmpty()) {
          return microStreamBatch;
        }
 else {
          continue;
        }
      }
      if (streamMessage.getOffset() < 0) {
        consumer.stop();
        logger.warn("streaming encountered EOF, stop building");
        return null;
      }
      microStreamBatch.incRawMessageCount();
      final ParsedStreamMessage parsedStreamMessage=getStreamParser().parse(streamMessage);
      if (getStreamFilter().filter(parsedStreamMessage)) {
        final long timestamp=parsedStreamMessage.getTimestamp();
        if (timestamp < startTimestamp) {
          streamMessageQueue.take();
        }
 else         if (timestamp < endTimestamp) {
          streamMessageQueue.take();
          if (microStreamBatch.size() >= condition.getBatchSize()) {
            return microStreamBatch;
          }
 else {
            microStreamBatch.add(parsedStreamMessage);
          }
        }
 else {
          return microStreamBatch;
        }
      }
 else {
        streamMessageQueue.take();
      }
    }
  }
 catch (  Exception e) {
    logger.error("build stream error, stop building",e);
    throw new RuntimeException("build stream error, stop building",e);
  }
 finally {
    countDownLatch.countDown();
  }
}

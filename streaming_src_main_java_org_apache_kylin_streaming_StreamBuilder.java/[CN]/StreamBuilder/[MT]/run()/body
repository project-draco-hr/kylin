{
  try {
    final int inputCount=streamMessageQueues.size();
    final ExecutorService executorService=Executors.newFixedThreadPool(inputCount);
    long start=startTimestamp;
    while (true) {
      CountDownLatch countDownLatch=new CountDownLatch(inputCount);
      ArrayList<Future<MicroStreamBatch>> futures=Lists.newArrayListWithExpectedSize(inputCount);
      for (      BlockingQueue<StreamMessage> streamMessageQueue : streamMessageQueues) {
        futures.add(executorService.submit(new StreamFetcher(streamMessageQueue,countDownLatch,start,start + condition.getBatchInterval())));
      }
      countDownLatch.await();
      ArrayList<MicroStreamBatch> batches=Lists.newArrayListWithExpectedSize(inputCount);
      for (      Future<MicroStreamBatch> future : futures) {
        if (future.get() != null) {
          batches.add(future.get());
        }
 else {
          consumer.stop();
          return;
        }
      }
      MicroStreamBatch batch=batches.get(0);
      if (batches.size() > 1) {
        for (int i=1; i < inputCount; i++) {
          batch=MicroStreamBatch.union(batch,batches.get(i));
        }
      }
      batch.getTimestamp().setFirst(start);
      batch.getTimestamp().setSecond(start + condition.getBatchInterval());
      start+=condition.getBatchInterval();
      consumer.consume(batch);
    }
  }
 catch (  InterruptedException e) {
    throw new RuntimeException("stream fetcher thread should not be interrupted",e);
  }
catch (  ExecutionException e) {
    logger.error("stream fetch thread encountered exception",e);
    throw new RuntimeException("stream fetch thread encountered exception",e);
  }
catch (  Exception e) {
    logger.error("consumer encountered exception",e);
    throw new RuntimeException("consumer encountered exception",e);
  }
}

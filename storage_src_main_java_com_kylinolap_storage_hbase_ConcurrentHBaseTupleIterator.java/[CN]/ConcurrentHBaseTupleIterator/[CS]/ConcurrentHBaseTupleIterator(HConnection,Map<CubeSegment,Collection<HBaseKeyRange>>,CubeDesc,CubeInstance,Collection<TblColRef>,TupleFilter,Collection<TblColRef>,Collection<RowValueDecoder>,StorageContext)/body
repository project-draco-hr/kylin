{
  this.conn=conn;
  this.segmentKeyRanges=segmentKeyRanges;
  this.cube=cube;
  this.dimensions=dimensions;
  this.groupBy=groupBy;
  this.aliasMap=context.getAliasMap();
  this.filter=filter;
  this.rowValueDecoders=rowValueDecoders;
  this.limit=context.getLimit();
  this.isLimitEnable=context.isLimitEnable();
  this.threshold=context.getThreshold();
  this.acceptPartialResult=context.isAcceptPartialResult();
  this.context=context;
  rangesCounter=new AtomicLong(0);
  for (  Collection<HBaseKeyRange> ranges : this.segmentKeyRanges.values()) {
    rangesCounter.addAndGet(ranges.size());
  }
  logger.debug("Start to scan " + rangesCounter.get() + " ranges..");
  for (  CubeSegment cubeSegment : this.segmentKeyRanges.keySet()) {
    for (    HBaseKeyRange keyRange : this.segmentKeyRanges.get(cubeSegment)) {
      Collection<RowValueDecoder> localRowValueDecoders=new ArrayList<RowValueDecoder>();
      for (      RowValueDecoder rowValueDecoder : this.rowValueDecoders) {
        localRowValueDecoders.add(new RowValueDecoder(rowValueDecoder));
      }
      ListenableFuture<Long> scanFuture=executor.submit(new RangeScanCallable(cubeSegment,keyRange,localRowValueDecoders));
      Futures.addCallback(scanFuture,new FutureCallback<Long>(){
        public void onSuccess(        Long scanCount){
          rangesCounter.decrementAndGet();
          scanCounter.addAndGet(scanCount);
          logger.debug("Scan count " + scanCount);
        }
        public void onFailure(        Throwable thrown){
          logger.debug("Scan failed due to " + thrown,thrown);
          scanExceptions.add(thrown);
        }
      }
);
      scanFutures.add(scanFuture);
    }
  }
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
      executor.shutdown();
    }
  }
);
}

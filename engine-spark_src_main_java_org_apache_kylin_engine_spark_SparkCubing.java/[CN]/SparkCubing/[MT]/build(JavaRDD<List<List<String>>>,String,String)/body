{
  final JavaPairRDD<byte[],byte[]> javaPairRDD=javaRDD.mapPartitionsToPair(new PairFlatMapFunction<Iterator<List<List<String>>>,byte[],byte[]>(){
    @Override public Iterable<Tuple2<byte[],byte[]>> call(    Iterator<List<List<String>>> listIterator) throws Exception {
      prepare();
      final CubeInstance cubeInstance=CubeManager.getInstance(KylinConfig.getInstanceFromEnv()).getCube(cubeName);
      final CubeDesc cubeDesc=cubeInstance.getDescriptor();
      final CubeSegment cubeSegment=cubeInstance.getSegmentById(segmentId);
      final Map<TblColRef,Dictionary<?>> dictionaryMap=Maps.newHashMap();
      for (      DimensionDesc dim : cubeDesc.getDimensions()) {
        for (        TblColRef col : dim.getColumnRefs()) {
          if (cubeDesc.getRowkey().isUseDictionary(col)) {
            Dictionary<?> dict=cubeSegment.getDictionary(col);
            if (dict == null) {
              System.err.println("Dictionary for " + col + " was not found.");
            }
            dictionaryMap.put(col,dict);
          }
        }
      }
      final Iterator<Iterator<Tuple2<byte[],byte[]>>> iterator=Iterators.transform(listIterator,new Function<List<List<String>>,Iterator<Tuple2<byte[],byte[]>>>(){
        @Nullable @Override public Iterator<Tuple2<byte[],byte[]>> apply(        @Nullable List<List<String>> input){
          if (input.isEmpty()) {
            return Collections.emptyIterator();
          }
          LinkedBlockingQueue<List<String>> blockingQueue=new LinkedBlockingQueue<List<String>>();
          final List<Tuple2<byte[],byte[]>> result=Lists.newLinkedList();
          InMemCubeBuilder inMemCubeBuilder=new InMemCubeBuilder(cubeInstance.getDescriptor(),dictionaryMap);
          final Future<?> future=Executors.newCachedThreadPool().submit(inMemCubeBuilder.buildAsRunnable(blockingQueue,new ICuboidWriter(){
            final int measureCount=cubeDesc.getMeasures().size();
            int[] measureColumnsIndex=new int[measureCount];
            ByteBuffer valueBuf=ByteBuffer.allocate(RowConstants.ROWVALUE_BUFFER_SIZE);
            @Override public void write(            long cuboidId,            GTRecord record) throws IOException {
              int bytesLength=RowConstants.ROWKEY_CUBOIDID_LEN;
              Cuboid cuboid=Cuboid.findById(cubeDesc,cuboidId);
              for (              TblColRef column : cuboid.getColumns()) {
                bytesLength+=cubeSegment.getColumnLength(column);
                final Dictionary<?> dictionary=cubeSegment.getDictionary(column);
              }
              final int dimensions=BitSet.valueOf(new long[]{cuboidId}).cardinality();
              for (int i=0; i < measureCount; i++) {
                measureColumnsIndex[i]=dimensions + i;
              }
              byte[] key=new byte[bytesLength];
              System.arraycopy(Bytes.toBytes(cuboidId),0,key,0,RowConstants.ROWKEY_CUBOIDID_LEN);
              int offSet=RowConstants.ROWKEY_CUBOIDID_LEN;
              for (int x=0; x < dimensions; x++) {
                final ByteArray byteArray=record.get(x);
                System.arraycopy(byteArray.array(),byteArray.offset(),key,offSet,byteArray.length());
                offSet+=byteArray.length();
              }
              valueBuf.clear();
              record.exportColumns(measureColumnsIndex,valueBuf);
              byte[] value=new byte[valueBuf.position()];
              System.arraycopy(valueBuf.array(),0,value,0,valueBuf.position());
              result.add(new Tuple2<byte[],byte[]>(key,value));
            }
            @Override public void flush(){
            }
          }
));
          try {
            for (            List<String> row : input) {
              blockingQueue.put(row);
            }
            blockingQueue.put(Collections.<String>emptyList());
            future.get();
          }
 catch (          Exception e) {
            throw new RuntimeException(e);
          }
          return result.iterator();
        }
      }
);
      return new Iterable<Tuple2<byte[],byte[]>>(){
        @Override public Iterator<Tuple2<byte[],byte[]>> iterator(){
          return Iterators.concat(iterator);
        }
      }
;
    }
  }
);
  final KylinConfig kylinConfig=KylinConfig.getInstanceFromEnv();
  final CubeInstance cubeInstance=CubeManager.getInstance(kylinConfig).getCube(cubeName);
  final CubeSegment cubeSegment=cubeInstance.getSegmentById(segmentId);
  Configuration conf=getConfigurationForHFile(cubeSegment.getStorageLocationIdentifier());
  Path path=new Path(kylinConfig.getHdfsWorkingDirectory(),"hfile_" + UUID.randomUUID().toString());
  Preconditions.checkArgument(!FileSystem.get(conf).exists(path));
  String url=conf.get("fs.defaultFS") + path.toString();
  System.out.println("use " + url + " as hfile");
  javaPairRDD.reduceByKey(new Function2<byte[],byte[],byte[]>(){
    @Override public byte[] call(    byte[] v1,    byte[] v2) throws Exception {
      prepare();
      final KylinConfig kylinConfig=KylinConfig.getInstanceFromEnv();
      final CubeManager cubeManager=CubeManager.getInstance(kylinConfig);
      final CubeInstance cubeInstance=cubeManager.reloadCubeLocal(cubeName);
      final CubeDesc cubeDesc=cubeInstance.getDescriptor();
      List<MeasureDesc> measuresDescs=Lists.newArrayList();
      for (      HBaseColumnFamilyDesc cfDesc : cubeDesc.getHBaseMapping().getColumnFamily()) {
        for (        HBaseColumnDesc colDesc : cfDesc.getColumns()) {
          for (          MeasureDesc measure : colDesc.getMeasures()) {
            measuresDescs.add(measure);
          }
        }
      }
      MeasureCodec codec=new MeasureCodec(measuresDescs);
      MeasureAggregators aggs=new MeasureAggregators(measuresDescs);
      Object[] input=new Object[measuresDescs.size()];
      Object[] result=new Object[measuresDescs.size()];
      codec.decode(ByteBuffer.wrap(v1),input);
      aggs.aggregate(input);
      codec.decode(ByteBuffer.wrap(v2),input);
      aggs.aggregate(input);
      aggs.collectStates(result);
      final ByteBuffer buffer=ByteBuffer.allocate(Math.max(v1.length,v2.length));
      buffer.clear();
      codec.encode(result,buffer);
      byte[] bytes=new byte[buffer.position()];
      System.arraycopy(buffer.array(),buffer.arrayOffset(),bytes,0,buffer.position());
      return bytes;
    }
  }
).sortByKey(UnsignedBytes.lexicographicalComparator()).mapToPair(new PairFunction<Tuple2<byte[],byte[]>,ImmutableBytesWritable,KeyValue>(){
    @Override public Tuple2<ImmutableBytesWritable,KeyValue> call(    Tuple2<byte[],byte[]> tuple2) throws Exception {
      ImmutableBytesWritable key=new ImmutableBytesWritable(tuple2._1());
      KeyValue value=new KeyValue(tuple2._1(),"F1".getBytes(),"M".getBytes(),tuple2._2());
      return new Tuple2(key,value);
    }
  }
).saveAsNewAPIHadoopFile(url,ImmutableBytesWritable.class,KeyValue.class,HFileOutputFormat.class,conf);
  return url;
}

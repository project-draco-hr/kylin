{
  final String log="rebuild cache type: " + cacheType + " name:"+ cacheKey;
  try {
switch (cacheType) {
case CUBE:
      CubeInstance newCube=getCubeManager().reloadCubeLocal(cacheKey);
    getProjectManager().clearL2Cache();
  super.cleanDataCache(newCube.getUuid());
mergeCubeOnNewSegmentReady(cacheKey);
break;
case CUBE_DESC:
getCubeDescManager().reloadCubeDescLocal(cacheKey);
break;
case PROJECT:
ProjectInstance projectInstance=getProjectManager().reloadProjectLocal(cacheKey);
removeOLAPDataSource(projectInstance.getName());
break;
case INVERTED_INDEX:
getIIManager().reloadIILocal(cacheKey);
getProjectManager().clearL2Cache();
break;
case INVERTED_INDEX_DESC:
getIIDescManager().reloadIIDescLocal(cacheKey);
break;
case TABLE:
getMetadataManager().reloadTableCache(cacheKey);
IIDescManager.clearCache();
CubeDescManager.clearCache();
break;
case DATA_MODEL:
getMetadataManager().reloadDataModelDesc(cacheKey);
IIDescManager.clearCache();
CubeDescManager.clearCache();
break;
case ALL:
getMetadataManager().reload();
CubeDescManager.clearCache();
CubeManager.clearCache();
IIDescManager.clearCache();
IIManager.clearCache();
ProjectManager.clearCache();
removeAllOLAPDataSources();
break;
default :
throw new RuntimeException("invalid cacheType:" + cacheType);
}
}
 catch (IOException e) {
throw new RuntimeException("error " + log,e);
}
}

{
  final String log="rebuild cache type: " + cacheType + " name:"+ cacheKey;
  try {
switch (cacheType) {
case CUBE:
      getCubeManager().loadCubeCache(cacheKey);
    cubeService.updateOnNewSegmentReady(cacheKey);
  getHybridManager().reloadHybridInstanceByChild(RealizationType.CUBE,cacheKey);
cleanProjectCacheByRealization(RealizationType.CUBE,cacheKey);
break;
case CUBE_DESC:
CubeDesc oldDesc=getCubeDescManager().getCubeDesc(cacheKey);
if (oldDesc != null) {
String modelName=oldDesc.getModelName();
getMetadataManager().reloadDataModelDesc(modelName);
}
getCubeDescManager().reloadCubeDesc(cacheKey);
break;
case PROJECT:
getProjectManager().reloadProject(cacheKey);
break;
case INVERTED_INDEX:
getIIManager().loadIICache(cacheKey);
getHybridManager().reloadHybridInstanceByChild(RealizationType.INVERTED_INDEX,cacheKey);
cleanProjectCacheByRealization(RealizationType.INVERTED_INDEX,cacheKey);
break;
case INVERTED_INDEX_DESC:
getIIDescManager().reloadIIDesc(cacheKey);
break;
case TABLE:
getMetadataManager().reloadTableCache(cacheKey);
IIDescManager.clearCache();
CubeDescManager.clearCache();
break;
case DATA_MODEL:
if (getMetadataManager().getDataModelDesc(cacheKey) == null) {
getMetadataManager().reloadDataModelDesc(cacheKey);
}
break;
case ALL:
MetadataManager.clearCache();
CubeDescManager.clearCache();
CubeManager.clearCache();
IIDescManager.clearCache();
IIManager.clearCache();
HybridManager.clearCache();
RealizationRegistry.clearCache();
ProjectManager.clearCache();
BasicService.resetOLAPDataSources();
HBaseConnection.clearCache();
break;
default :
throw new RuntimeException("invalid cacheType:" + cacheType);
}
}
 catch (IOException e) {
throw new RuntimeException("error " + log,e);
}
}

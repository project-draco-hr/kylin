{
  checkAndRewriteTopN(context,sqlDigest,returnTupleInfo);
  Collection<TblColRef> groups=sqlDigest.groupbyColumns;
  TblColRef topNCol=extractTopNCol(groups);
  if (topNCol != null)   groups.remove(topNCol);
  TupleFilter filter=sqlDigest.filter;
  Collection<TblColRef> dimensions=new HashSet<TblColRef>();
  Collection<FunctionDesc> metrics=new HashSet<FunctionDesc>();
  buildDimensionsAndMetrics(dimensions,metrics,sqlDigest);
  Set<TblColRef> others=Sets.newHashSet(dimensions);
  others.removeAll(groups);
  Set<TblColRef> derivedPostAggregation=Sets.newHashSet();
  Set<TblColRef> groupsD=expandDerived(groups,derivedPostAggregation);
  Set<TblColRef> othersD=expandDerived(others,derivedPostAggregation);
  othersD.removeAll(groupsD);
  derivedPostAggregation.removeAll(groups);
  Set<TblColRef> dimensionsD=Sets.newHashSet();
  dimensionsD.addAll(groupsD);
  dimensionsD.addAll(othersD);
  Cuboid cuboid=identifyCuboid(dimensionsD);
  context.setCuboid(cuboid);
  Set<TblColRef> singleValuesD=findSingleValueColumns(filter);
  boolean isExactAggregation=isExactAggregation(cuboid,groups,othersD,singleValuesD,derivedPostAggregation);
  context.setExactAggregation(isExactAggregation);
  Set<TblColRef> groupsCopD=Sets.newHashSet(groupsD);
  collectNonEvaluable(filter,groupsCopD);
  TupleFilter filterD=translateDerived(filter,groupsCopD);
  TupleFilter flatFilter=flattenToOrAndFilter(filterD);
  List<HBaseKeyRange> scans=buildScanRanges(flatFilter,dimensionsD);
  List<RowValueDecoder> valueDecoders=translateAggregation(cubeDesc.getHBaseMapping(),metrics,context);
  setCoprocessor(groupsCopD,valueDecoders,context);
  setLimit(filter,context);
  HConnection conn=HBaseConnection.get(context.getConnUrl());
  return new SerializedHBaseTupleIterator(conn,scans,cubeInstance,dimensionsD,filterD,groupsCopD,topNCol,valueDecoders,context,returnTupleInfo);
}

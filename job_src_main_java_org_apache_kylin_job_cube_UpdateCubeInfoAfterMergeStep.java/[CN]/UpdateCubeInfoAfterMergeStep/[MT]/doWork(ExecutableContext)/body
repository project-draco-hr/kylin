{
  final CubeInstance cube=cubeManager.getCube(getCubeName());
  CubeSegment mergedSegment=cube.getSegmentById(getSegmentId());
  if (mergedSegment == null) {
    return new ExecuteResult(ExecuteResult.State.FAILED,"there is no segment with id:" + getSegmentId());
  }
  long cubeSize=0l;
  String cubeSizeString=executableManager.getOutput(getConvertToHfileStepId()).getExtra().get(ExecutableConstants.HDFS_BYTES_WRITTEN);
  if (StringUtils.isNotEmpty(cubeSizeString)) {
    cubeSize=Long.parseLong(cubeSizeString) / 1024;
  }
 else {
    logger.warn("Can not get cube segment size.");
  }
  List<String> mergingSegmentIds=getMergingSegmentIds();
  if (mergingSegmentIds.isEmpty()) {
    return new ExecuteResult(ExecuteResult.State.FAILED,"there are no merging segments");
  }
  long sourceCount=0L;
  long sourceSize=0L;
  for (  String id : mergingSegmentIds) {
    CubeSegment segment=cube.getSegmentById(id);
    sourceCount+=segment.getInputRecords();
    sourceSize+=segment.getInputRecordsSize();
  }
  mergedSegment.setSizeKB(cubeSize);
  mergedSegment.setInputRecords(sourceCount);
  mergedSegment.setInputRecordsSize(sourceSize);
  mergedSegment.setLastBuildJobID(getCubingJobId());
  mergedSegment.setLastBuildTime(System.currentTimeMillis());
  try {
    cubeManager.promoteNewlyBuiltSegments(cube,mergedSegment);
    return new ExecuteResult(ExecuteResult.State.SUCCEED);
  }
 catch (  IOException e) {
    logger.error("fail to update cube after merge",e);
    return new ExecuteResult(ExecuteResult.State.ERROR,e.getLocalizedMessage());
  }
}

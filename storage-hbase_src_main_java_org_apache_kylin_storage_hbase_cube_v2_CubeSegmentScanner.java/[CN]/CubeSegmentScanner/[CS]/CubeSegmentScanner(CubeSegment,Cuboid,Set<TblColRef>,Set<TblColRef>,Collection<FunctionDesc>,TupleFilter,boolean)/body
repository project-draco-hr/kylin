{
  this.cuboid=cuboid;
  this.cubeSeg=cubeSeg;
  this.info=CubeGridTable.newGTInfo(cubeSeg,cuboid.getId());
  CuboidToGridTableMapping mapping=cuboid.getCuboidToGridTableMapping();
  ITupleFilterTranslator translator=new TupleFilterDictionaryTranslater(this.cubeSeg);
  filter=translator.translate(filter);
  TupleFilter gtFilter=GTUtil.convertFilterColumnsAndConstants(filter,info,mapping.getCuboidDimensionsInGTOrder(),groups);
  ImmutableBitSet gtDimensions=makeGridTableColumns(mapping,dimensions);
  ImmutableBitSet gtAggrGroups=makeGridTableColumns(mapping,replaceDerivedColumns(groups,cubeSeg.getCubeDesc()));
  ImmutableBitSet gtAggrMetrics=makeGridTableColumns(mapping,metrics);
  String[] gtAggrFuncs=makeAggrFuncs(mapping,metrics);
  GTScanRangePlanner scanRangePlanner;
  if (cubeSeg.getCubeDesc().getModel().getPartitionDesc().isPartitioned()) {
    TblColRef tblColRef=cubeSeg.getCubeDesc().getModel().getPartitionDesc().getPartitionDateColumnRef();
    Pair<ByteArray,ByteArray> segmentStartAndEnd;
    int index=mapping.getIndexOf(tblColRef);
    if (index >= 0) {
      segmentStartAndEnd=getSegmentStartAndEnd(index);
    }
 else {
      throw new IllegalStateException("Cannot found partition column on cuboid to gt mapping:" + tblColRef);
    }
    scanRangePlanner=new GTScanRangePlanner(info,segmentStartAndEnd,info.colRef(index));
  }
 else {
    scanRangePlanner=new GTScanRangePlanner(info,null,null);
  }
  List<GTScanRange> scanRanges=scanRangePlanner.planScanRanges(gtFilter,MAX_SCAN_RANGES);
  scanRequests=Lists.newArrayListWithCapacity(scanRanges.size());
  KylinConfig config=cubeSeg.getCubeInstance().getConfig();
  for (  GTScanRange range : scanRanges) {
    GTScanRequest req=new GTScanRequest(info,range,gtDimensions,gtAggrGroups,gtAggrMetrics,gtAggrFuncs,gtFilter,allowPreAggregate,config.getQueryCoprocessorMemGB());
    scanRequests.add(req);
  }
  scanner=new Scanner();
}

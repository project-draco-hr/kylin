{
  boolean upgrade=false;
  DataModelDesc modelDesc=cubeDesc.getModel();
  try {
    if (modelDesc != null && modelDesc.getDimensions() == null && modelDesc.getMetrics() == null) {
      List<org.apache.kylin.cube.model.DimensionDesc> cubeDimDescList=cubeDesc.getDimensions();
      if (!CollectionUtils.isEmpty(cubeDimDescList)) {
        Map<String,HashSet<String>> modelDimMap=Maps.newHashMap();
        for (        org.apache.kylin.cube.model.DimensionDesc cubeDimDesc : cubeDimDescList) {
          if (!modelDimMap.containsKey(cubeDimDesc.getTable())) {
            modelDimMap.put(cubeDimDesc.getTable(),new HashSet<String>());
          }
          modelDimMap.get(cubeDimDesc.getTable()).addAll(Lists.newArrayList(cubeDimDesc.getDerived() != null ? cubeDimDesc.getDerived() : new String[]{cubeDimDesc.getColumn()}));
        }
        List<DimensionDesc> modelDimDescList=Lists.newArrayListWithCapacity(modelDimMap.size());
        for (        Map.Entry<String,HashSet<String>> modelDimEntry : modelDimMap.entrySet()) {
          DimensionDesc dimDesc=new DimensionDesc();
          dimDesc.setTable(modelDimEntry.getKey());
          String[] columns=new String[modelDimEntry.getValue().size()];
          columns=modelDimEntry.getValue().toArray(columns);
          dimDesc.setColumns(columns);
          modelDimDescList.add(dimDesc);
        }
        DimensionDesc.capicalizeStrings(modelDimDescList);
        modelDesc.setDimensions(modelDimDescList);
        upgrade=true;
      }
      List<MeasureDesc> cubeMeasDescList=cubeDesc.getMeasures();
      if (!CollectionUtils.isEmpty(cubeDimDescList)) {
        ArrayList<String> metrics=Lists.newArrayListWithExpectedSize(cubeMeasDescList.size());
        for (        MeasureDesc cubeMeasDesc : cubeMeasDescList) {
          for (          TblColRef tblColRef : cubeMeasDesc.getFunction().getParameter().getColRefs()) {
            metrics.add(tblColRef.getName());
          }
        }
        String[] metricsArray=new String[metrics.size()];
        modelDesc.setMetrics(metrics.toArray(metricsArray));
        upgrade=true;
      }
    }
    if (upgrade) {
      store.putResource(modelDesc.getResourcePath(),modelDesc,MetadataManager.MODELDESC_SERIALIZER);
      updatedResources.add(modelDesc.getResourcePath());
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    errorMsgs.add("Update DataModelDesc[" + modelDesc.getName() + "] failed: "+ e.getLocalizedMessage());
  }
}

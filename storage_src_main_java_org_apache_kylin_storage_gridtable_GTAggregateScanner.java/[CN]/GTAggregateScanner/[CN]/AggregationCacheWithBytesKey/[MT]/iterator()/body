{
  return new Iterator<GTRecord>(){
    final Iterator<Entry<byte[],MeasureAggregator[]>> it=aggBufMap.entrySet().iterator();
    final ByteBuffer metricsBuf=ByteBuffer.allocate(info.getMaxColumnLength(metrics));
    final GTRecord secondRecord;
{
      BitSet dimensionsAndMetrics=(BitSet)groupBy.clone();
      dimensionsAndMetrics.or(metrics);
      secondRecord=new GTRecord(info,dimensionsAndMetrics);
    }
    @Override public boolean hasNext(){
      return it.hasNext();
    }
    @Override public GTRecord next(){
      Entry<byte[],MeasureAggregator[]> entry=it.next();
      create(entry.getKey(),entry.getValue());
      return secondRecord;
    }
    private void create(    byte[] key,    MeasureAggregator[] value){
      int offset=0;
      for (int i=groupBy.nextSetBit(0); i >= 0; i=groupBy.nextSetBit(i + 1)) {
        final int columnLength=info.codeSystem.maxCodeLength(i);
        secondRecord.set(i,new ByteArray(key,offset,columnLength));
        offset+=columnLength;
      }
      metricsBuf.clear();
      for (int i=0, col=-1; i < value.length; i++) {
        col=metrics.nextSetBit(col + 1);
        int pos=metricsBuf.position();
        info.codeSystem.encodeColumnValue(col,value[i].getState(),metricsBuf);
        secondRecord.cols[col].set(metricsBuf.array(),pos,metricsBuf.position() - pos);
      }
    }
    @Override public void remove(){
      throw new UnsupportedOperationException();
    }
  }
;
}

{
  final String cubeName=kafkaConfig.getCubeName();
  final CubeInstance cubeInstance=CubeManager.getInstance(kylinConfig).getCube(cubeName);
  final List<BlockingQueue<StreamMessage>> queues=consume(kafkaConfig,partitionCount);
  final LinkedBlockingDeque<StreamMessage> streamQueue=new LinkedBlockingDeque<>();
  Executors.newSingleThreadExecutor().execute(new Runnable(){
    @Override public void run(){
      int totalMessage=0;
      while (true) {
        for (        BlockingQueue<StreamMessage> queue : queues) {
          try {
            streamQueue.put(queue.take());
            if (totalMessage++ % 10000 == 1) {
              logger.info("Total stream message count: " + totalMessage);
            }
          }
 catch (          InterruptedException e) {
            throw new RuntimeException(e);
          }
        }
      }
    }
  }
);
  CubeStreamBuilder cubeStreamBuilder=new CubeStreamBuilder(streamQueue,cubeName);
  cubeStreamBuilder.setStreamParser(getStreamParser(kafkaConfig,cubeInstance.getAllColumns()));
  cubeStreamBuilder.setStreamFilter(getStreamFilter(kafkaConfig));
  final Future<?> future=Executors.newSingleThreadExecutor().submit(cubeStreamBuilder);
  future.get();
}

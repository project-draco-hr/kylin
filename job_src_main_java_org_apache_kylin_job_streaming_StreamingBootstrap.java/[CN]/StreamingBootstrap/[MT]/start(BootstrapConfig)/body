{
  final String streaming=bootstrapConfig.getStreaming();
  Preconditions.checkNotNull(streaming,"streaming name cannot be empty");
  final StreamingConfig streamingConfig=streamingManager.getStreamingConfig(streaming);
  Preconditions.checkArgument(streamingConfig != null,"cannot find kafka config:" + streaming);
  if (!StringUtils.isEmpty(streamingConfig.getIiName())) {
    int partitionId=bootstrapConfig.getPartitionId();
    Preconditions.checkArgument(partitionId >= 0,"partitionId cannot be empty for inverted index streaming");
    startIIStreaming(streamingConfig,partitionId);
  }
 else   if (!StringUtils.isEmpty(streamingConfig.getCubeName())) {
    if (bootstrapConfig.isFillGap()) {
      final List<Pair<Long,Long>> gaps=StreamingMonitor.findGaps(streamingConfig.getCubeName());
      logger.info("all gaps:" + StringUtils.join(gaps,","));
      for (      Pair<Long,Long> gap : gaps) {
        startOneOffCubeStreaming(streamingConfig,gap.getFirst(),gap.getSecond(),streamingConfig.getMargin());
      }
    }
 else {
      if (bootstrapConfig.isOneOff()) {
        Preconditions.checkArgument(bootstrapConfig.getStart() != 0);
        Preconditions.checkArgument(bootstrapConfig.getEnd() != 0);
        startOneOffCubeStreaming(streamingConfig,bootstrapConfig.getStart(),bootstrapConfig.getEnd(),streamingConfig.getMargin());
      }
 else {
        startCubeStreaming(streamingConfig);
      }
    }
  }
 else {
    throw new IllegalArgumentException("no cube or ii in kafka config");
  }
}

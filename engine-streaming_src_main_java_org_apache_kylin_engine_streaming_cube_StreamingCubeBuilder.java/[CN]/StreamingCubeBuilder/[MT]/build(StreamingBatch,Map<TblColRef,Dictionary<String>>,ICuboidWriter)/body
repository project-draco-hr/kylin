{
  try {
    CubeManager cubeManager=CubeManager.getInstance(KylinConfig.getInstanceFromEnv());
    final CubeInstance cubeInstance=cubeManager.reloadCubeLocal(cubeName);
    LinkedBlockingQueue<List<String>> blockingQueue=new LinkedBlockingQueue<List<String>>();
    InMemCubeBuilder inMemCubeBuilder=new InMemCubeBuilder(cubeInstance.getDescriptor(),dictionaryMap);
    final Future<?> future=Executors.newCachedThreadPool().submit(inMemCubeBuilder.buildAsRunnable(blockingQueue,cuboidWriter));
    processedRowCount=streamingBatch.getMessages().size();
    for (    StreamingMessage streamingMessage : streamingBatch.getMessages()) {
      blockingQueue.put(streamingMessage.getData());
    }
    blockingQueue.put(Collections.<String>emptyList());
    future.get();
    cuboidWriter.flush();
  }
 catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
catch (  ExecutionException e) {
    throw new RuntimeException("error build cube from StreamingBatch",e.getCause());
  }
catch (  IOException e) {
    throw new RuntimeException("error build cube from StreamingBatch",e.getCause());
  }
 finally {
    try {
      cuboidWriter.close();
    }
 catch (    IOException e) {
      throw new RuntimeException("error build cube from StreamingBatch",e.getCause());
    }
  }
}
